<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ULTRAKILL HTML Demake - ULTIMATE (Fixed)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html,body { height:100%; }
        body {
            background-color: #0a0a1a;
            color: #ff003c;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            cursor: none; /* custom crosshair drawn on canvas */
            image-rendering: pixelated;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 4px solid #ff003c;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px #ff003c;
            transform: translateZ(0);
            background: #1a1a2a;
        }

        canvas { width:100%; height:100%; display:block; image-rendering: pixelated; }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
        }

        .health-bar { width: 200px; height: 20px; background-color: #330000; border:2px solid #ff003c; border-radius:4px; overflow:hidden; }
        #health-fill { height:100%; width:100%; background: linear-gradient(90deg,#ff003c,#ff335f); transition: width 200ms linear; box-shadow:0 0 10px #ff003c; }

        #style-container { display:flex; flex-direction:column; align-items:center; pointer-events:none; }
        #style-meter { font-size: 20px; font-weight:bold; text-shadow: 0 0 8px #ff003c; color:#fff; letter-spacing:1px; }
        #style-bar { width:200px; height:10px; background: #222; border:1px solid #ff003c; border-radius:5px; overflow:hidden; margin-top:6px; }
        #style-fill { height:100%; width:0%; background: linear-gradient(90deg,#00ccff,#ff00ff); transition: width 350ms ease-out; box-shadow: 0 0 10px #ff00ff; }

        #score { font-size: 18px; color:#fff; text-shadow: 0 0 5px #ff003c; }

        #stats-container {
            position:absolute;
            bottom:10px;
            left:10px;
            font-size:14px;
            color:#fff;
            text-shadow:0 0 3px #ff003c;
            background: rgba(0,0,0,0.45);
            padding:6px 10px;
            border-radius:5px;
            border:1px solid #ff003c;
            z-index:11;
            pointer-events:none;
        }

        #weapon-display {
            position:absolute;
            bottom:10px;
            right:10px;
            font-size:16px;
            color:#fff;
            text-shadow:0 0 5px #ff003c;
            background: rgba(0,0,0,0.45);
            padding:6px 10px;
            border-radius:5px;
            border:1px solid #ff003c;
            z-index:11;
            pointer-events:none;
        }

        #abilities-display { position:absolute; bottom:50px; left:10px; display:flex; gap:10px; z-index:11; pointer-events:none; }
        .ability { width:44px; height:44px; background:rgba(0,0,0,0.5); border:1px solid #ff003c; border-radius:5px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:12px; pointer-events:none; text-align:center; }
        .ability.cooldown { opacity:0.45; transform:scale(0.95); transition:transform 160ms; }

        #start-screen {
            position:absolute; top:0; left:0; width:100%; height:100%;
            background: linear-gradient(rgba(10,10,26,0.95), rgba(30,0,20,0.95));
            display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:20;
        }

        h1 { font-size:64px; color:#ff003c; text-shadow:0 0 15px #ff003c; letter-spacing:4px; animation:pulse 2s infinite; }
        .title-bg { position:absolute; font-size:80px; color: rgba(255,0,60,0.07); top:calc(50% - 120px); font-weight:bold; }

        @keyframes pulse {
            0% { text-shadow: 0 0 15px #ff003c; transform: scale(1); }
            50% { text-shadow: 0 0 25px #ff003c, 0 0 35px #ff003c; transform: scale(1.05); }
            100% { text-shadow: 0 0 15px #ff003c; transform: scale(1); }
        }

        .menu-options { display:flex; flex-direction:column; gap:12px; margin-top:20px; }
        .menu-option { padding:10px 26px; background-color: rgba(255,0,60,0.28); color:#fff; border:2px solid #ff003c; border-radius:8px; font-size:18px; cursor:pointer; text-transform:uppercase; letter-spacing:1px; transition:all 180ms; }
        .menu-option:hover { transform:scale(1.04); background-color: rgba(255,0,60,0.55); box-shadow:0 0 15px #ff003c; }

        #controls-info { margin-top:18px; color:#fff; text-align:center; font-size:14px; max-width:80%; background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; border:1px solid #ff003c; }

        #blood-overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; opacity:1; z-index:5; }
        .blood-splat { position:absolute; width:200px; height:200px; background: radial-gradient(circle, rgba(255,0,60,0.8) 0%, rgba(255,0,60,0) 70%); border-radius:50%; transform:scale(0); animation:bloodSplat 500ms forwards; mix-blend-mode:overlay; }
        @keyframes bloodSplat { to { transform:scale(1); opacity:0; } }

        #game-over { position:absolute; top:0; left:0; width:100%; height:100%; background-color: rgba(0,0,0,0.9); display:none; flex-direction:column; align-items:center; justify-content:center; z-index:25; }
        #restart-button { padding:12px 30px; background:#ff003c; color:#fff; border:none; border-radius:8px; font-size:20px; cursor:pointer; margin-top:18px; transition:all 160ms; }
        #restart-button:hover { background:#ff335f; box-shadow:0 0 20px #ff003c; }

        #grain-overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:15; opacity:0.04; mix-blend-mode:overlay; }
        #vignette { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:16; box-shadow: inset 0 0 150px rgba(0,0,0,0.9); }
        #scanlines { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:17; background: linear-gradient(to bottom, rgba(255,0,60,0.03) 50%, rgba(0,0,0,0) 50%); background-size:100% 4px; opacity:0.22; }

        .damage-flash { position:absolute; top:0; left:0; width:100%; height:100%; background-color:rgba(255,0,60,0.28); pointer-events:none; opacity:0; z-index:18; transition:opacity 120ms ease-out; }

        #combo-display { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:44px; color:#fff; text-shadow: 0 0 10px #ff003c; opacity:0; z-index:19; font-weight:bold; pointer-events:none; transition:opacity 200ms; }

        #guidebook { position:absolute; top:0; left:0; width:100%; height:100%; background-color: rgba(10,10,26,0.98); display:none; flex-direction:column; align-items:center; padding:20px; z-index:30; overflow-y:auto; color:#fff; }

        .enemy-info { background: rgba(0,0,0,0.65); border:2px solid #ff003c; border-radius:8px; padding:12px; margin-bottom:12px; width:90%; max-width:600px; }
        .enemy-visual { width:100px; height:100px; margin:0 auto 10px; border:2px solid #ff003c; border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:14px; color:white; }

        .aim-line { position:absolute; pointer-events:none; z-index:8; }

        #intensity-overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:20; opacity:0; background: radial-gradient(circle at center, transparent 30%, rgba(255,0,60,0.06) 100%); mix-blend-mode: screen; transition:opacity 200ms linear; }

        .hit-marker { position:absolute; width:20px; height:20px; border:2px solid #ffcc00; border-radius:50%; pointer-events:none; z-index:22; animation: hitMarker 300ms forwards; transform-origin:center center; }
        @keyframes hitMarker { 0% { transform: scale(0); opacity: 0; } 50% { transform: scale(1.5); opacity:1;} 100% { transform: scale(1); opacity:0; } }

        .dash-effect, .parry-effect { position:absolute; width:100%; height:100%; pointer-events:none; z-index:13; opacity:0; }
        .dash-effect { background: linear-gradient(90deg, transparent 0%, rgba(0,204,255,0.12) 50%, transparent 100%); animation: dashEffect 400ms forwards; }
        @keyframes dashEffect { 0% { opacity:0; transform:translateX(-100%);} 50% { opacity:1; transform:translateX(0%);} 100% { opacity:0; transform:translateX(100%);} }
        .parry-effect { background: radial-gradient(circle, rgba(0,255,100,0.18) 0%, transparent 70%); animation: parryEffect 500ms forwards; }
        @keyframes parryEffect { 0% { opacity:0; transform:scale(0);} 50% { opacity:1; transform:scale(1);} 100% { opacity:0; transform:scale(1.5);} }

        /* small responsive tweak */
        @media (max-width:820px) { #game-container { transform: scale(0.9); } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>

        <div id="blood-overlay"></div>
        <div id="grain-overlay"></div>
        <div id="vignette"></div>
        <div id="scanlines"></div>
        <div class="damage-flash" id="damage-flash"></div>
        <div id="combo-display">+COMBO</div>
        <div id="intensity-overlay"></div>

        <div id="ui-container">
            <div class="health-bar"><div id="health-fill"></div></div>
            <div id="style-container">
                <div id="style-meter">DESTRUCTIVE</div>
                <div id="style-bar"><div id="style-fill"></div></div>
            </div>
            <div id="score">SCORE: 0</div>
        </div>

        <div id="stats-container">
            <div>KILLS: <span id="kill-count">0</span></div>
            <div>COMBO: <span id="combo-count">0</span>x</div>
            <div>ACCURACY: <span id="accuracy">100%</span></div>
        </div>

        <div id="weapon-display">REVOLVER [1]</div>

        <div id="abilities-display">
            <div class="ability" id="dash-ability">DASH<br>[SHIFT]</div>
            <div class="ability" id="parry-ability">PARRY<br>[E]</div>
        </div>

        <div id="start-screen">
            <div style="position:relative; margin-bottom:20px;">
                <div class="title-bg">ULTRAKILL</div>
                <h1>RETROKILL</h1>
            </div>

            <div class="menu-options">
                <div class="menu-option" id="play-button">START GAME</div>
                <div class="menu-option" id="guidebook-button">GUIDEBOOK</div>
            </div>

            <div id="controls-info">
                <p>CONTROLS: WASD to move, MOUSE to aim, LEFT CLICK to shoot</p>
                <p>SHIFT to dash, E to parry, 1-3 to switch weapons</p>
                <p>Collect blood to regain health. Higher style = more points!</p>
            </div>
        </div>

        <div id="game-over">
            <h2 style="color:#ff003c;">MACHINE TURNED OFF</h2>
            <div id="final-score" style="color:#fff; margin-top:6px;">SCORE: 0</div>
            <div id="final-stats" style="color:#fff; margin-top:8px;">
                <div>KILLS: <span id="final-kills">0</span></div>
                <div>MAX COMBO: <span id="final-combo">0</span>x</div>
                <div>ACCURACY: <span id="final-accuracy">100%</span></div>
            </div>
            <button id="restart-button">TRY AGAIN</button>
        </div>

        <div id="guidebook">
            <h2 style="color:#ff003c; font-size:28px; margin-bottom:12px;">ENEMY GUIDEBOOK</h2>

            <div class="enemy-info">
                <div class="enemy-visual" style="background: linear-gradient(135deg,#6666ff,#3333aa);">FILTH</div>
                <h3 style="color:#ff003c;">FILTH</h3>
                <div class="enemy-desc" style="color:#fff;">Basic enemy that slowly moves toward the player. Weak but can swarm in numbers.<br><br><strong>Strategy:</strong> Easy to kill with any weapon. Keep your distance and take them out quickly before they surround you.</div>
            </div>

            <div class="enemy-info">
                <div class="enemy-visual" style="background: linear-gradient(135deg,#ff3333,#aa0000);">SCHISM</div>
                <h3 style="color:#ff003c;">SCHISM</h3>
                <div class="enemy-desc" style="color:#fff;">Stronger enemy with more health. Moves faster and deals more damage than Filth.<br><br><strong>Strategy:</strong> Use your Revolver for precision shots or Shotgun for close-range damage. Watch for their charge attack.</div>
            </div>

            <div class="enemy-info">
                <div class="enemy-visual" style="background: linear-gradient(135deg,#ffff00,#aaaa00);">IDOL</div>
                <h3 style="color:#ff003c;">IDOL</h3>
                <div class="enemy-desc" style="color:#fff;">Support enemy that buffs nearby enemies, making them faster and more dangerous.<br><br><strong>Strategy:</strong> Prioritize killing Idols first. Their buff aura makes other enemies much more threatening.</div>
            </div>

            <button id="back-button" style="padding:8px 18px; background:#ff003c; color:#fff; border:none; border-radius:8px; cursor:pointer; margin-top:6px;">BACK TO MENU</button>
        </div>
    </div>

    <script>
    // -------------------------
    // Fixed & improved game JS
    // - key fixes: defined gameContainer, stable game loop timing, safe math checks,
    //   proper alpha rendering for particles/bullets, safer DOM removals, crosshair, small polish
    // -------------------------

    // DOM references
    const gameContainer = document.getElementById('game-container'); // was missing before
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d', { alpha: true });

    // UI elements
    const startScreen = document.getElementById('start-screen');
    const playButton = document.getElementById('play-button');
    const guidebookButton = document.getElementById('guidebook-button');
    const guidebook = document.getElementById('guidebook');
    const backButton = document.getElementById('back-button');
    const gameOverScreen = document.getElementById('game-over');
    const restartButton = document.getElementById('restart-button');
    const healthFill = document.getElementById('health-fill');
    const styleMeter = document.getElementById('style-meter');
    const styleFill = document.getElementById('style-fill');
    const scoreDisplay = document.getElementById('score');
    const finalScoreDisplay = document.getElementById('final-score');
    const bloodOverlay = document.getElementById('blood-overlay');
    const weaponDisplay = document.getElementById('weapon-display');
    const damageFlash = document.getElementById('damage-flash');
    const comboDisplay = document.getElementById('combo-display');
    const killCount = document.getElementById('kill-count');
    const comboCount = document.getElementById('combo-count');
    const accuracyDisplay = document.getElementById('accuracy');
    const finalKills = document.getElementById('final-kills');
    const finalCombo = document.getElementById('final-combo');
    const finalAccuracy = document.getElementById('final-accuracy');
    const dashAbility = document.getElementById('dash-ability');
    const parryAbility = document.getElementById('parry-ability');
    const intensityOverlay = document.getElementById('intensity-overlay');

    // Game state
    let gameActive = false;
    let player = null;
    let enemies = [];
    let bloodDrops = [];
    let bullets = [];
    let particles = [];
    let score = 0;
    let styleLevel = 0;
    let stylePoints = 0;
    let styleTimeout = null;
    let lastTime = 0;
    let keys = {};
    let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
    let cameraShake = 0;
    let shotsFired = 0;
    let shotsHit = 0;
    let kills = 0;
    let combo = 0;
    let comboTimeout = null;
    let maxCombo = 0;
    let difficulty = 1;
    let dashCooldown = 0;
    let parryCooldown = 0;
    let parryActive = false;
    let parryTime = 0;
    let intensityLevel = 0;

    // Weapons
    const weapons = [
        { name: "REVOLVER", key: "1", damage: 1, cooldown: 0.2, speed: 12, color: "#ffcc00", precision: 0.95 },
        { name: "SHOTGUN", key: "2", damage: 3, cooldown: 0.8, speed: 8, color: "#ff3300", precision: 0.7, pellets: 5 },
        { name: "NAILGUN", key: "3", damage: 0.5, cooldown: 0.1, speed: 10, color: "#00ccff", precision: 0.85 }
    ];
    let currentWeapon = 0;

    // Style ranks & thresholds
    const styleRankings = ["DESTRUCTIVE","DISASTROUS","DEVASTATING","DISGUSTING","BLOODBATH","ULTRAKILL"];
    const styleThresholds = [0,5,15,30,50,75];

    // Utility
    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

    // Player class
    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 20;
            this.speed = 5;
            this.health = 100;
            this.maxHealth = 100;
            this.color = '#ff003c';
            this.shootCooldown = 0;
            this.rotation = 0;
            this.dashPower = 15;
            this.dashTime = 0;
            this.dashDuration = 0.2;
            this.dashing = false;
            this.parryDuration = 0.3;
        }

        update(deltaTime) {
            // Dashing countdown
            if (this.dashing) {
                this.dashTime -= deltaTime;
                if (this.dashTime <= 0) this.dashing = false;
            }

            // Movement input
            let moveX = 0, moveY = 0;
            if (keys['KeyW']) moveY -= 1;
            if (keys['KeyS']) moveY += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            if (moveX !== 0 || moveY !== 0) {
                const len = Math.hypot(moveX, moveY) || 1;
                moveX /= len; moveY /= len;
            }

            const moveSpeed = this.dashing ? this.speed * 3 : this.speed;
            this.x += moveX * moveSpeed;
            this.y += moveY * moveSpeed;

            // Rotation towards mouse
            this.rotation = Math.atan2(mouse.y - this.y, mouse.x - this.x);

            // Keep inside bounds
            this.x = clamp(this.x, this.radius, canvas.width - this.radius);
            this.y = clamp(this.y, this.radius, canvas.height - this.radius);

            // Shooting cooldown
            if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;

            // Parry handling
            if (parryActive) {
                parryTime -= deltaTime;
                if (parryTime <= 0) parryActive = false;
            }
        }

        draw() {
            // camera shake offsets
            const shakeX = cameraShake > 0 ? (Math.random() - 0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random() - 0.5) * cameraShake : 0;

            ctx.save();
            ctx.translate(this.x + shakeX, this.y + shakeY);
            ctx.rotate(this.rotation);

            // Parry aura
            if (parryActive) {
                ctx.beginPath();
                ctx.arc(0,0,this.radius+10,0,Math.PI*2);
                ctx.fillStyle = 'rgba(0,255,100,0.18)';
                ctx.fill();
            }

            // Body
            ctx.beginPath();
            ctx.arc(0,0,this.radius,0,Math.PI*2);
            ctx.fillStyle = this.dashing ? '#00ccff' : this.color;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Gun indicator
            ctx.beginPath();
            ctx.moveTo(this.radius - 5, -5);
            ctx.lineTo(this.radius + 15, 0);
            ctx.lineTo(this.radius - 5, 5);
            ctx.closePath();
            ctx.fillStyle = '#333';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        shoot() {
            if (this.shootCooldown > 0) return;
            this.shootCooldown = weapons[currentWeapon].cooldown;
            shotsFired++;
            updateAccuracy();

            const weapon = weapons[currentWeapon];
            const baseAngle = this.rotation;

            if (weapon.name === "SHOTGUN") {
                for (let i=0;i<weapon.pellets;i++){
                    const spread = (Math.random()-0.5)*(1 - weapon.precision) * 1.5;
                    this.fireBullet(baseAngle + spread, weapon);
                }
            } else {
                const spread = (Math.random()-0.5)*(1 - weapon.precision) * 0.3;
                this.fireBullet(baseAngle + spread, weapon);
            }

            // camera shake
            cameraShake = Math.max(cameraShake, weapon.name === "SHOTGUN" ? 8 : 5);

            // Muzzle flash particles
            for (let i=0;i<(weapon.name==="SHOTGUN"?12:6); i++){
                const spread = (Math.random()-0.5)*0.3;
                particles.push(new Particle(
                    this.x + Math.cos(baseAngle)*this.radius,
                    this.y + Math.sin(baseAngle)*this.radius,
                    Math.cos(baseAngle + spread) * (8 + Math.random()*8),
                    Math.sin(baseAngle + spread) * (8 + Math.random()*8),
                    weapon.color,
                    2 + Math.random()*3,
                    0.25 + Math.random()*0.25
                ));
            }
        }

        fireBullet(angle, weapon) {
            bullets.push(new Bullet(
                this.x + Math.cos(angle)*this.radius,
                this.y + Math.sin(angle)*this.radius,
                angle,
                weapon.speed,
                weapon.color,
                weapon.damage
            ));
        }

        dash() {
            if (dashCooldown > 0 || this.dashing) return;
            this.dashing = true;
            this.dashTime = this.dashDuration;
            dashCooldown = 0.5;

            // dash DOM effect
            const dashEffect = document.createElement('div');
            dashEffect.className = 'dash-effect';
            gameContainer.appendChild(dashEffect);
            setTimeout(()=>{ if (dashEffect.parentNode) dashEffect.parentNode.removeChild(dashEffect); }, 420);

            // dash particles
            const baseAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
            for (let i=0;i<22;i++){
                const spread = (Math.random()-0.5) * Math.PI;
                particles.push(new Particle(
                    this.x, this.y,
                    Math.cos(baseAngle + spread) * (10 + Math.random()*12),
                    Math.sin(baseAngle + spread) * (10 + Math.random()*12),
                    '#00ccff',
                    2 + Math.random()*3,
                    0.5 + Math.random()*0.4
                ));
            }
        }

        parry() {
            if (parryCooldown > 0 || parryActive) return;
            parryActive = true;
            parryTime = this.parryDuration;
            parryCooldown = 1;

            const parryEffect = document.createElement('div');
            parryEffect.className = 'parry-effect';
            gameContainer.appendChild(parryEffect);
            setTimeout(()=>{ if (parryEffect.parentNode) parryEffect.parentNode.removeChild(parryEffect); }, 520);

            // reflect nearby bullets
            for (const b of bullets) {
                const dx = b.x - this.x;
                const dy = b.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < this.radius + 22) {
                    const angle = Math.atan2(dy, dx);
                    b.angle = angle + Math.PI;
                    b.speed *= 1.5;
                    b.color = '#00ff66';
                    increaseStyle(5);
                }
            }
        }

        takeDamage(amount) {
            this.health -= amount;
            this.health = Math.max(0, this.health);
            healthFill.style.width = `${(this.health / this.maxHealth) * 100}%`;

            damageFlash.style.opacity = '0.8';
            setTimeout(()=>{ damageFlash.style.opacity = '0'; }, 120);

            cameraShake = Math.max(cameraShake, 10);

            combo = 0;
            comboCount.textContent = combo;

            if (this.health <= 0) gameOver();
        }

        heal(amount) {
            this.health = Math.min(this.maxHealth, this.health + amount);
            healthFill.style.width = `${(this.health / this.maxHealth) * 100}%`;
            for (let i=0;i<6;i++){
                particles.push(new Particle(
                    this.x, this.y,
                    (Math.random()-0.5)*3, (Math.random()-0.5)*3,
                    '#ff003c', 2 + Math.random()*2, 0.8 + Math.random()*0.6
                ));
            }
        }
    }

    // Enemy class
    class Enemy {
        constructor(x,y,type){
            this.x = x; this.y = y; this.type = type;
            this.baseSpeed = 1.5;
            if (type === 'FILTH') { this.radius=15; this.speed=this.baseSpeed*1.25; this.health=3; this.color='#6666ff'; this.damage=10; this.score=100; }
            else if (type === 'SCHISM') { this.radius=25; this.speed=this.baseSpeed*2; this.health=8; this.color='#ff3333'; this.damage=15; this.score=200; }
            else if (type === 'IDOL') { this.radius=20; this.speed=this.baseSpeed*1.2; this.health=5; this.color='#ffff00'; this.damage=5; this.score=300; this.buffRadius=150; }
            this.attackCooldown = 0;
            this.buffing = false;
        }

        update(deltaTime){
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist === 0) dist = 0.0001;

            if (this.type === 'IDOL') {
                this.buffing = false;
                // reset speed to base scaled by difficulty
                this.speed = this.baseSpeed * (1 + 0.1 * difficulty);

                for (const enemy of enemies) {
                    if (enemy !== this && enemy.type !== 'IDOL') {
                        const edx = enemy.x - this.x;
                        const edy = enemy.y - this.y;
                        const edist = Math.hypot(edx, edy);
                        if (edist < this.buffRadius) {
                            enemy.speed = enemy.baseSpeed * (enemy.type === 'FILTH' ? 2.5 * difficulty : 2 * difficulty);
                            this.buffing = true;
                        }
                    }
                }

                if (!this.buffing) {
                    // approach but slowly
                    if (dist > 200) {
                        this.x += (dx / dist) * this.speed * 0.6;
                        this.y += (dy / dist) * this.speed * 0.6;
                    } else if (dist < 150) {
                        this.x -= (dx / dist) * this.speed * 0.6;
                        this.y -= (dy / dist) * this.speed * 0.6;
                    }
                } else {
                    // remain roughly where you are
                }
            } else {
                // ensure speed is appropriate
                this.speed = this.baseSpeed * (this.type === 'FILTH' ? 2 * difficulty : 1.5 * difficulty);
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }

            if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;

            const contactDist = Math.hypot(player.x - this.x, player.y - this.y);
            if (contactDist < this.radius + player.radius && this.attackCooldown <= 0) {
                player.takeDamage(this.damage);
                this.attackCooldown = 1;
                createBloodSplat(player.x, player.y);
            }
        }

        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;

            ctx.save();
            ctx.translate(this.x + shakeX, this.y + shakeY);

            ctx.beginPath();
            ctx.arc(0,0,this.radius,0,Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();

            if (this.type === 'SCHISM') {
                ctx.beginPath();
                ctx.arc(0,0,this.radius - 5,0,Math.PI*2);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                for (let i=0;i<8;i++){
                    const a = (i/8)*Math.PI*2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(a)*(this.radius-3), Math.sin(a)*(this.radius-3));
                    ctx.lineTo(Math.cos(a)*(this.radius+5), Math.sin(a)*(this.radius+5));
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            } else if (this.type === 'IDOL') {
                ctx.beginPath();
                ctx.arc(0,0,this.radius-3,0,Math.PI*2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.stroke();
                if (this.buffing) {
                    ctx.beginPath();
                    ctx.arc(0,0,this.radius+5,0,Math.PI*2);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5,5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.restore();
        }

        takeDamage(amount){
            this.health -= amount;
            for (let i=0;i<8;i++){
                particles.push(new Particle(
                    this.x, this.y,
                    (Math.random()-0.5)*5, (Math.random()-0.5)*5,
                    '#ff003c', 2 + Math.random()*2, 0.5 + Math.random()*0.6
                ));
            }
            if (this.health <= 0) {
                for (let i=0;i<5;i++){
                    bloodDrops.push(new BloodDrop(this.x + (Math.random()-0.5)*20, this.y + (Math.random()-0.5)*20));
                }

                const points = Math.round(this.score * (styleLevel + 1) * (combo > 0 ? combo : 1));
                score += points;
                scoreDisplay.textContent = `SCORE: ${score}`;

                kills++;
                killCount.textContent = kills;

                increaseCombo();
                increaseStyle(3);
                createBloodSplat(this.x, this.y);

                cameraShake = Math.max(cameraShake, 8);
                return true;
            }
            return false;
        }
    }

    // Bullet
    class Bullet {
        constructor(x,y,angle,speed,color,damage){
            this.x=x; this.y=y; this.angle=angle; this.speed=speed; this.radius=3; this.color=color; this.damage=damage;
        }
        update(){
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            // trail
            particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*2, (Math.random()-0.5)*2, this.color, 1 + Math.random()*2, 0.22));
            // out of bounds
            if (this.x < -20 || this.x > canvas.width + 20 || this.y < -20 || this.y > canvas.height + 20) return true;
            return false;
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.globalAlpha = 0.28;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius + 3, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }
    }

    // BloodDrop (pickup for heal)
    class BloodDrop {
        constructor(x,y){ this.x=x; this.y=y; this.radius=5; this.color='#ff003c'; this.life=10; }
        update(){
            this.life -= 0.016;
            if (this.life <= 0) return true;
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < this.radius + player.radius) {
                player.heal(10);
                increaseStyle(1);
                for (let i=0;i<6;i++){
                    particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*3, (Math.random()-0.5)*3, '#ff003c', 1 + Math.random()*2, 0.5));
                }
                return true;
            }
            return false;
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const pulse = Math.sin(Date.now()/200) * 1.5;
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius + pulse, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.globalAlpha = 0.28;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius + pulse + 3, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255,0,60,0.3)';
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }
    }

    // Particle (improved alpha handling)
    class Particle {
        constructor(x,y,vx,vy,color,size,life){
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.color=color; this.size=size; this.life=life; this.maxLife=life;
        }
        update(){
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.016;
            this.vx *= 0.95; this.vy *= 0.95;
            return this.life <= 0;
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const alpha = clamp(this.life / this.maxLife, 0, 1);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.size * alpha, 0, Math.PI*2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }
    }

    // visual effects (DOM)
    function createBloodSplat(x,y){
        const splat = document.createElement('div');
        splat.className = 'blood-splat';
        splat.style.left = `${x - 100}px`;
        splat.style.top = `${y - 100}px`;
        bloodOverlay.appendChild(splat);
        setTimeout(()=>{ if (splat.parentNode) splat.parentNode.removeChild(splat); }, 520);
    }

    function createHitMarker(x,y){
        const marker = document.createElement('div');
        marker.className = 'hit-marker';
        marker.style.left = `${x - 10}px`;
        marker.style.top = `${y - 10}px`;
        gameContainer.appendChild(marker);
        setTimeout(()=>{ if (marker.parentNode) marker.parentNode.removeChild(marker); }, 320);
    }

    // Style system
    function increaseStyle(amount){
        stylePoints += amount;
        // find new level
        let newLevel = 0;
        for (let i = styleThresholds.length - 1; i >= 0; i--) {
            if (stylePoints >= styleThresholds[i]) { newLevel = i; break; }
        }
        if (newLevel > styleLevel) {
            cameraShake = Math.max(cameraShake, 12);
            styleMeter.style.textShadow = '0 0 20px #ff00ff';
            setTimeout(()=>{ styleMeter.style.textShadow = '0 0 8px #ff003c'; }, 220);
        }
        styleLevel = newLevel;
        styleMeter.textContent = styleRankings[styleLevel] || styleRankings[styleRankings.length - 1];

        const nextThreshold = styleLevel < styleThresholds.length - 1 ? styleThresholds[styleLevel + 1] : styleThresholds[styleLevel] * 2;
        const progress = (stylePoints - styleThresholds[styleLevel]) / Math.max(1, (nextThreshold - styleThresholds[styleLevel]));
        styleFill.style.width = `${clamp(progress, 0, 1) * 100}%`;

        if (styleTimeout) clearTimeout(styleTimeout);
        startStyleDecay();
    }

    function startStyleDecay() {
        if (stylePoints <= 0) return;
        const decayRate = 0.12 / (1 + difficulty * 0.5); // tuned
        styleTimeout = setTimeout(() => {
            stylePoints = Math.max(0, stylePoints - decayRate);
            // update display
            let newLevel = 0;
            for (let i = styleThresholds.length - 1; i >= 0; i--) {
                if (stylePoints >= styleThresholds[i]) { newLevel = i; break; }
            }
            styleLevel = newLevel;
            styleMeter.textContent = styleRankings[styleLevel];
            const nextThreshold = styleLevel < styleThresholds.length - 1 ? styleThresholds[styleLevel + 1] : styleThresholds[styleLevel] * 2;
            const progress = styleLevel > 0 ? (stylePoints - styleThresholds[styleLevel]) / Math.max(1, (nextThreshold - styleThresholds[styleLevel])) : stylePoints / Math.max(1, nextThreshold);
            styleFill.style.width = `${clamp(progress,0,1) * 100}%`;
            if (stylePoints > 0) startStyleDecay();
        }, 120);
    }

    // combo
    function increaseCombo(){
        combo++;
        comboCount.textContent = combo;
        if (combo > maxCombo) maxCombo = combo;
        if (combo % 5 === 0) {
            comboDisplay.textContent = `+${combo} COMBO!`;
            comboDisplay.style.opacity = '1';
            setTimeout(()=>{ comboDisplay.style.opacity='0'; }, 900);
        }
        if (comboTimeout) clearTimeout(comboTimeout);
        comboTimeout = setTimeout(()=>{ combo=0; comboCount.textContent=combo; }, 3000);
    }

    // accuracy
    function updateAccuracy(){
        const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 100;
        accuracyDisplay.textContent = `${accuracy}%`;
    }

    // aim assist and aim line
    function drawAimLine(){
        if (!player || !gameActive) return;
        const angle = player.rotation;
        const length = 220;
        const endX = player.x + Math.cos(angle) * length;
        const endY = player.y + Math.sin(angle) * length;

        let assistX = endX, assistY = endY, closestDist = Infinity;

        for (const enemy of enemies) {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 180) {
                const enemyAngle = Math.atan2(dy, dx);
                let angleDiff = Math.abs(angle - enemyAngle);
                angleDiff = Math.min(angleDiff, Math.PI*2 - angleDiff);
                if (angleDiff < 0.36 && dist < closestDist) {
                    closestDist = dist;
                    assistX = enemy.x; assistY = enemy.y;
                }
            }
        }

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(assistX, assistY);
        ctx.strokeStyle = 'rgba(255,204,0,0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(assistX, assistY, 3, 0, Math.PI*2);
        ctx.fillStyle = '#ffcc00';
        ctx.fill();
        ctx.restore();
    }

    // intensity overlay
    function updateIntensity(){
        intensityLevel = 0.18 * styleLevel + 0.09 * combo + 0.05 * enemies.length;
        intensityLevel = clamp(intensityLevel, 0, 1);
        intensityOverlay.style.opacity = `${intensityLevel * 0.5}`;
    }

    // game over
    function gameOver() {
        gameActive = false;
        finalScoreDisplay.textContent = `SCORE: ${score}`;
        finalKills.textContent = kills;
        finalCombo.textContent = maxCombo;
        const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 100;
        finalAccuracy.textContent = `${accuracy}%`;
        gameOverScreen.style.display = 'flex';
    }

    // spawn enemy (recursive with timeout)
    function spawnEnemy(){
        if (!gameActive) return;
        difficulty = 1 + (score / 5000) + (styleLevel * 0.2);
        const rand = Math.random();
        let type;
        if (rand < 0.6) type = 'FILTH';
        else if (rand < 0.9) type = 'SCHISM';
        else type = 'IDOL';

        const side = Math.floor(Math.random() * 4);
        let x,y;
        switch(side){
            case 0: x = Math.random()*canvas.width; y = -40; break;
            case 1: x = canvas.width + 40; y = Math.random()*canvas.height; break;
            case 2: x = Math.random()*canvas.width; y = canvas.height + 40; break;
            default: x = -40; y = Math.random()*canvas.height; break;
        }
        enemies.push(new Enemy(x,y,type));

        const nextSpawn = Math.max(300, 1400 - (score / 20));
        setTimeout(spawnEnemy, nextSpawn);
    }

    // crosshair draw
    function drawCrosshair(){
        const cx = mouse.x, cy = mouse.y;
        ctx.save();
        ctx.translate(cx, cy);
        const t = Date.now() / 120;
        const pulse = 1 + Math.sin(t) * 0.06;
        // outer glow
        ctx.beginPath();
        ctx.arc(0,0,8*pulse,0,Math.PI*2);
        ctx.fillStyle = 'rgba(255,204,0,0.07)';
        ctx.fill();
        // lines
        ctx.strokeStyle = '#ffcc00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12,0); ctx.lineTo(-6,0);
        ctx.moveTo(12,0); ctx.lineTo(6,0);
        ctx.moveTo(0,-12); ctx.lineTo(0,-6);
        ctx.moveTo(0,12); ctx.lineTo(0,6);
        ctx.stroke();
        ctx.restore();
    }

    // Main loop
    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const deltaTime = Math.min(0.05, (timestamp - lastTime) / 1000);
        lastTime = timestamp;

        // shake decay
        if (cameraShake > 0) {
            cameraShake *= 0.86;
            if (cameraShake < 0.4) cameraShake = 0;
        }

        // cooldown updates
        if (dashCooldown > 0) { dashCooldown -= deltaTime; dashAbility.classList.toggle('cooldown', dashCooldown > 0); }
        if (parryCooldown > 0) { parryCooldown -= deltaTime; parryAbility.classList.toggle('cooldown', parryCooldown > 0); }

        // clear
        ctx.clearRect(0,0,canvas.width, canvas.height);

        if (gameActive) {
            drawAimLine();

            // update player
            player.update(deltaTime);

            // update enemies (backwards removal)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.update(deltaTime);
                e.draw();
            }

            // bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                if (b.update()) { bullets.splice(i,1); continue; }
                // collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const en = enemies[j];
                    const dx = b.x - en.x, dy = b.y - en.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < b.radius + en.radius) {
                        shotsHit++; updateAccuracy();
                        createHitMarker(b.x, b.y);
                        if (en.takeDamage(b.damage)) enemies.splice(j,1);
                        bullets.splice(i,1);
                        break;
                    }
                }
                if (i < bullets.length) b.draw();
            }

            // blood drops
            for (let i = bloodDrops.length - 1; i >= 0; i--) {
                if (bloodDrops[i].update()) { bloodDrops.splice(i,1); continue; }
                bloodDrops[i].draw();
            }

            // particles
            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].update()) { particles.splice(i,1); continue; }
                particles[i].draw();
            }

            player.draw();
            drawCrosshair();
            updateIntensity();
        } else {
            // draw idle crosshair on menu too
            drawCrosshair();
        }

        requestAnimationFrame(gameLoop);
    }

    // switch weapon
    function switchWeapon(index) {
        if (index >= 0 && index < weapons.length) {
            currentWeapon = index;
            weaponDisplay.textContent = `${weapons[currentWeapon].name} [${weapons[currentWeapon].key}]`;
            weaponDisplay.style.textShadow = '0 0 10px #ffcc00';
            setTimeout(()=>{ weaponDisplay.style.textShadow = '0 0 5px #ff003c'; }, 200);
        }
    }

    // init/reset
    function initGame() {
        player = new Player();
        enemies = []; bloodDrops = []; bullets = []; particles = [];
        score = 0; styleLevel = 0; stylePoints = 0; cameraShake = 0;
        shotsFired = 0; shotsHit = 0; kills = 0; combo = 0; maxCombo = 0;
        difficulty = 1; dashCooldown = 0; parryCooldown = 0; parryActive = false;
        intensityLevel = 0;

        healthFill.style.width = '100%';
        styleMeter.textContent = styleRankings[styleLevel];
        styleFill.style.width = '0%';
        scoreDisplay.textContent = `SCORE: ${score}`;
        weaponDisplay.textContent = `${weapons[currentWeapon].name} [${weapons[currentWeapon].key}]`;
        killCount.textContent = '0'; comboCount.textContent = '0'; accuracyDisplay.textContent = '100%';

        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        guidebook.style.display = 'none';
        gameActive = true;

        // spawn loop
        setTimeout(spawnEnemy, 900);

        if (styleTimeout) clearTimeout(styleTimeout);
        startStyleDecay();
    }

    // input
    playButton.addEventListener('click', ()=>initGame());
    guidebookButton.addEventListener('click', ()=>{ startScreen.style.display='none'; guidebook.style.display='flex'; });
    backButton.addEventListener('click', ()=>{ guidebook.style.display='none'; startScreen.style.display='flex'; });
    restartButton.addEventListener('click', ()=>{ initGame(); });

    window.addEventListener('keydown', (e)=>{
        keys[e.code] = true;
        if (e.code === 'Digit1') switchWeapon(0);
        if (e.code === 'Digit2') switchWeapon(1);
        if (e.code === 'Digit3') switchWeapon(2);
        if (e.code === 'ShiftLeft' && gameActive && player) player.dash();
        if (e.code === 'KeyE' && gameActive && player) player.parry();
    });
    window.addEventListener('keyup', (e)=>{ keys[e.code] = false; });

    canvas.addEventListener('mousemove', (e)=>{
        const rect = canvas.getBoundingClientRect();
        mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    });

    canvas.addEventListener('click', (e)=>{
        if (gameActive && player) {
            player.shoot();
        } else {
            // click to start if on start screen
            if (!gameActive && startScreen.style.display !== 'none') initGame();
        }
    });

    // Prevent selection/dblclick weirdness
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // kick off loop
    requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
