<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>RETROKILL: ULTRA ENHANCED</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* Previous styles remain, adding new ones below */
        
        /* Enhanced transitions */
        * {
            transition: all 0.3s ease-out;
        }
        
        /* Multiplayer screens */
        #multiplayer-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 950;
            color: #fff;
            padding: 20px;
        }
        
        .multiplayer-content {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #ff003c;
            border-radius: 10px;
            padding: 30px;
            width: 500px;
            max-width: 90%;
        }
        
        .multiplayer-option {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 0, 60, 0.2);
            border: 2px solid #ff003c;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
        }
        
        .multiplayer-option:hover {
            background: rgba(255, 0, 60, 0.4);
            transform: scale(1.05);
        }
        
        .setting-select {
            width: 100%;
            padding: 8px;
            background: #222;
            color: #fff;
            border: 2px solid #ff003c;
            border-radius: 5px;
            margin-top: 5px;
        }
        
        /* Shield health bar enhancements */
        #shield-bar {
            background: linear-gradient(90deg, #00ccff, #0066ff);
            box-shadow: 0 0 10px #00ccff;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        
        .shield-active {
            animation: shieldPulse 2s infinite;
        }
        
        @keyframes shieldPulse {
            0%, 100% { box-shadow: 0 0 5px #00ccff; }
            50% { box-shadow: 0 0 15px #00ccff, 0 0 20px #0066ff; }
        }
        
        /* New enemy conversion effect */
        .conversion-effect {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid #00ff00;
            border-radius: 50%;
            box-shadow: 0 0 20px #00ff00;
            animation: convertPulse 1.5s forwards;
            pointer-events: none;
            z-index: 25;
        }
        
        @keyframes convertPulse {
            0% { transform: scale(0.5); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
        
        /* Ally indicator */
        .ally-indicator {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #00ff00;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ff00;
            animation: allyPulse 2s infinite;
            z-index: 26;
        }
        
        @keyframes allyPulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        /* Obstacle styles */
        .obstacle {
            position: absolute;
            background: #555;
            border: 2px solid #999;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            z-index: 5;
        }
        
        /* Stage transition animation */
        .stage-transition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ff003c;
            z-index: 100;
            opacity: 0;
            animation: stageTransition 1.5s forwards;
            pointer-events: none;
        }
        
        @keyframes stageTransition {
            0% { opacity: 0; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(1.2); }
        }
        
        /* New UI animations */
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #ff003c; }
            50% { box-shadow: 0 0 20px #ff003c, 0 0 30px rgba(255, 0, 60, 0.5); }
        }
        
        /* Enhanced weapon switch animation */
        .weapon-switch {
            animation: weaponSwitch 0.5s forwards;
        }
        
        @keyframes weaponSwitch {
            0% { transform: translateX(20px); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }
        
        /* Health regen effect */
        .heal-effect {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255,0,60,0.5) 0%, transparent 70%);
            border-radius: 50%;
            animation: healPulse 1s forwards;
            pointer-events: none;
            z-index: 15;
        }
        
        @keyframes healPulse {
            0% { transform: scale(0.5); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 0; }
        }
    </style>
</head>
<body class="crt">
    <!-- Previous HTML structure remains -->
    
    <!-- Add multiplayer menu -->
    <div id="multiplayer-menu">
        <div class="multiplayer-content">
            <h2 style="color: #ff003c; text-align: center;">MULTIPLAYER</h2>
            
            <div id="host-panel">
                <h3 style="margin: 15px 0; color: #fff;">HOST GAME</h3>
                
                <div class="setting-item">
                    <label class="setting-label">Max Players</label>
                    <select class="setting-select" id="max-players">
                        <option value="2">2 Players</option>
                        <option value="3">3 Players</option>
                        <option value="4">4 Players</option>
                    </select>
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">Difficulty Scaling</label>
                    <select class="setting-select" id="difficulty-scaling">
                        <option value="1">Normal</option>
                        <option value="1.2">Hard</option>
                        <option value="1.5">Ultra</option>
                        <option value="2">Nightmare</option>
                    </select>
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">Enemy Filter</label>
                    <select class="setting-select" id="enemy-filter">
                        <option value="all">All Enemies</option>
                        <option value="no_titan">No Titans</option>
                        <option value="no_nightmare">No Nightmares</option>
                        <option value="only_filth">Only Filth</option>
                    </select>
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">Modifiers</label>
                    <select class="setting-select" id="game-modifiers" multiple>
                        <option value="double_damage">Double Damage</option>
                        <option value="half_health">Half Health</option>
                        <option value="infinite_ammo">Infinite Ammo</option>
                        <option value="permadeath">Permadeath</option>
                    </select>
                </div>
                
                <div class="multiplayer-option" id="create-game-btn">CREATE GAME</div>
            </div>
            
            <div id="join-panel" style="display: none;">
                <h3 style="margin: 15px 0; color: #fff;">JOIN GAME</h3>
                
                <div class="setting-item">
                    <label class="setting-label">Game Code</label>
                    <input type="text" class="setting-select" id="game-code-input" placeholder="Enter game code">
                </div>
                
                <div class="multiplayer-option" id="join-game-btn">JOIN</div>
            </div>
            
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <div class="multiplayer-option" id="switch-to-join">JOIN GAME</div>
                <div class="multiplayer-option" id="switch-to-host">HOST GAME</div>
                <div class="multiplayer-option" id="multiplayer-back">BACK</div>
            </div>
        </div>
    </div>

    <script>
    // -------------------------
    // ENHANCED RETROKILL: ULTRA
    // - Added detailed transitions and animations
    // - Implemented progressive zoom with play area expansion
    // - Added substage system with buffs and obstacles
    // - Implemented shield health system
    // - Added multiplayer functionality (UI only)
    // -------------------------

    // New game state variables
    let substage = 0;
    let playerAllies = [];
    let obstacles = [];
    let gameCode = "";
    let isHost = false;
    let multiplayerPlayers = 1;
    let enemyFilter = "all";
    let gameModifiers = [];
    let healthRegenTimer = 0;
    let conversionCooldown = 0;
    let stageTransitionActive = false;
    let playAreaExpansion = 1.0;
    let basePlayAreaSize = 1.0;

    // Enhanced Player class with shield system
    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 20;
            this.speed = 5;
            this.health = 100;
            this.maxHealth = 100;
            this.shieldHealth = 0;
            this.maxShieldHealth = 200;
            this.color = '#ff003c';
            this.shootCooldown = 0;
            this.rotation = 0;
            this.dashPower = 15;
            this.dashTime = 0;
            this.dashDuration = 0.2;
            this.dashing = false;
            this.parryDuration = 0.3;
            this.trail = [];
            this.trailLength = 10;
            this.invulnerable = false;
            this.shieldDamageReduction = 0.7; // 30% less damage with shield
            this.cooldownReduction = 0; // Will scale with shield amount
        }

        update(deltaTime) {
            // Apply cooldown reduction from shield
            const effectiveCooldownReduction = 1 - (this.cooldownReduction * (this.shieldHealth / this.maxShieldHealth));
            
            // Dashing countdown
            if (this.dashing) {
                this.dashTime -= deltaTime;
                if (this.dashTime <= 0) this.dashing = false;
            }

            // Movement input
            let moveX = 0, moveY = 0;
            if (keys['KeyW']) moveY -= 1;
            if (keys['KeyS']) moveY += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            if (moveX !== 0 || moveY !== 0) {
                const len = Math.hypot(moveX, moveY) || 1;
                moveX /= len; moveY /= len;
            }

            const moveSpeed = this.dashing ? this.speed * 3 : this.speed;
            this.x += moveX * moveSpeed;
            this.y += moveY * moveSpeed;

            // Add trail point
            this.trail.push({x: this.x, y: this.y, life: 1});
            if (this.trail.length > this.trailLength) this.trail.shift();

            // Aim assist interpolation
            let targetAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
            if (aimAssistTarget) {
                const dx = aimAssistTarget.x - this.x;
                const dy = aimAssistTarget.y - this.y;
                const targetAssistAngle = Math.atan2(dy, dx);
                targetAngle = lerp(targetAngle, targetAssistAngle, aimAssistStrength);
                aimAssistStrength = Math.max(0, aimAssistStrength - deltaTime * 2);
            }
            
            // Smooth rotation
            this.rotation = lerp(this.rotation, targetAngle, 0.2);

            // Keep inside bounds (scaled by playAreaSize)
            const bounds = getPlayAreaBounds();
            this.x = clamp(this.x, bounds.minX + this.radius, bounds.maxX - this.radius);
            this.y = clamp(this.y, bounds.minY + this.radius, bounds.maxY - this.radius);

            // Shooting cooldown with shield reduction
            if (this.shootCooldown > 0) this.shootCooldown -= deltaTime * effectiveCooldownReduction;

            // Parry handling with shield reduction
            if (parryActive) {
                parryTime -= deltaTime * effectiveCooldownReduction;
                if (parryTime <= 0) parryActive = false;
            }

            // Health regeneration in substage 1
            if (substage >= 1 && this.health < this.maxHealth) {
                healthRegenTimer += deltaTime;
                if (healthRegenTimer >= 1) { // Heal every second
                    this.heal(2); // 2 health per second
                    healthRegenTimer = 0;
                    
                    // Visual effect
                    const healEffect = document.createElement('div');
                    healEffect.className = 'heal-effect';
                    healEffect.style.left = (this.x - 25) + 'px';
                    healEffect.style.top = (this.y - 25) + 'px';
                    gameContainer.appendChild(healEffect);
                    setTimeout(() => {
                        gameContainer.removeChild(healEffect);
                    }, 1000);
                }
            }

            // Update trail
            for (let i = 0; i < this.trail.length; i++) {
                this.trail[i].life -= 0.05;
            }
            this.trail = this.trail.filter(point => point.life > 0);
        }

        // ... (other methods remain similar but with shield enhancements)

        takeDamage(amount) {
            if (this.invulnerable) return;
            
            // Apply damage to shield first with damage reduction
            if (this.shieldHealth > 0) {
                const shieldDamage = amount * this.shieldDamageReduction;
                this.shieldHealth -= shieldDamage;
                if (this.shieldHealth < 0) {
                    // If shield is depleted, apply remaining damage to health
                    amount = -this.shieldHealth / this.shieldDamageReduction;
                    this.shieldHealth = 0;
                    shieldBar.classList.remove('shield-active');
                } else {
                    amount = 0;
                }
                shieldBar.style.width = `${(this.shieldHealth / this.maxShieldHealth) * 100}%`;
            }
            
            // Apply remaining damage to health
            if (amount > 0) {
                this.health -= amount;
                this.health = Math.max(0, this.health);
                healthFill.style.width = `${(this.health / this.maxHealth) * 100}%`;
            }

            // Blood overlay effect
            bloodIntensity = Math.min(bloodIntensity + 0.3, 1.0);
            bloodOverlay.style.opacity = bloodIntensity;
            setTimeout(() => {
                bloodIntensity = Math.max(bloodIntensity - 0.05, 0);
                bloodOverlay.style.opacity = bloodIntensity;
            }, 300);

            cameraShake = Math.max(cameraShake, 10);
            screenShake(0.3);

            combo = 0;
            comboCount.textContent = combo;

            if (this.health <= 0) gameOver();
        }

        addShield(amount) {
            const hadShield = this.shieldHealth > 0;
            this.shieldHealth = Math.min(this.maxShieldHealth, this.shieldHealth + amount);
            shieldBar.style.width = `${(this.shieldHealth / this.maxShieldHealth) * 100}%`;
            
            // Activate shield effects if gaining shield
            if (!hadShield && this.shieldHealth > 0) {
                shieldBar.classList.add('shield-active');
                
                // Update cooldown reduction based on shield amount
                this.cooldownReduction = 0.3; // 30% max cooldown reduction at full shield
            }
            
            // Shield gain effect
            for (let i=0;i<8;i++){
                particles.push(new Particle(
                    this.x, this.y,
                    (Math.random()-0.5)*3, (Math.random()-0.5)*3,
                    '#00ccff', 2 + Math.random()*2, 0.8 + Math.random()*0.6,
                    false
                ));
            }
        }
    }

    // New Ally class (converted enemies)
    class Ally {
        constructor(enemy) {
            this.x = enemy.x;
            this.y = enemy.y;
            this.radius = enemy.radius;
            this.color = '#00ff00';
            this.speed = enemy.speed * 1.2; // Allies are faster
            this.damage = enemy.damage;
            this.attackCooldown = 0;
            this.target = null;
            this.lifetime = 30; // Seconds before ally disappears
        }

        update(deltaTime) {
            this.lifetime -= deltaTime;
            if (this.lifetime <= 0) return true; // Remove ally
            
            // Find closest enemy
            let closestDist = Infinity;
            this.target = null;
            
            for (const enemy of enemies) {
                const dist = distance(this.x, this.y, enemy.x, enemy.y);
                if (dist < closestDist) {
                    closestDist = dist;
                    this.target = enemy;
                }
            }
            
            // Move toward target
            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                
                // Attack if close enough
                if (dist < this.radius + this.target.radius + 10 && this.attackCooldown <= 0) {
                    this.target.takeDamage(this.damage);
                    this.attackCooldown = 1;
                }
            }
            
            if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
            
            return false; // Don't remove
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Draw ally body
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                -this.radius * 0.3, -this.radius * 0.3, 0,
                0, 0, this.radius
            );
            gradient.addColorStop(0, '#66ff66');
            gradient.addColorStop(1, '#00aa00');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Outer glow
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 3, 0, Math.PI * 2);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
            
            // Draw ally indicator above
            const indicator = document.createElement('div');
            indicator.className = 'ally-indicator';
            indicator.style.left = (this.x - 7.5) + 'px';
            indicator.style.top = (this.y - this.radius - 20) + 'px';
            gameContainer.appendChild(indicator);
            setTimeout(() => {
                if (gameContainer.contains(indicator)) {
                    gameContainer.removeChild(indicator);
                }
            }, 100);
        }
    }

    // New Obstacle class
    class Obstacle {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.02;
        }

        update() {
            this.rotation += this.rotationSpeed;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(this.rotation);
            
            ctx.fillStyle = '#555555';
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
            
            // Add some details
            ctx.strokeStyle = '#777777';
            ctx.beginPath();
            ctx.moveTo(-this.width/2, -this.height/2);
            ctx.lineTo(this.width/2, this.height/2);
            ctx.moveTo(this.width/2, -this.height/2);
            ctx.lineTo(-this.width/2, this.height/2);
            ctx.stroke();
            
            ctx.restore();
            
            // Create DOM element for collision
            const obstacleEl = document.createElement('div');
            obstacleEl.className = 'obstacle';
            obstacleEl.style.width = this.width + 'px';
            obstacleEl.style.height = this.height + 'px';
            obstacleEl.style.left = this.x + 'px';
            obstacleEl.style.top = this.y + 'px';
            obstacleEl.style.transform = `rotate(${this.rotation}rad)`;
            gameContainer.appendChild(obstacleEl);
            setTimeout(() => {
                if (gameContainer.contains(obstacleEl)) {
                    gameContainer.removeChild(obstacleEl);
                }
            }, 50);
        }
    }

    // Enhanced game initialization with multiplayer
    function initGame(isMultiplayer = false, isHosting = false) {
        player = new Player();
        enemies = []; bloodDrops = []; bullets = []; grenades = []; particles = []; explosions = [];
        playerAllies = []; obstacles = [];
        score = 0; styleLevel = 0; stylePoints = 0; cameraShake = 0;
        cameraOffset = { x: 0, y: 0 };
        cameraZoom = 1.0;
        shotsFired = 0; shotsHit = 0; kills = 0; combo = 0; maxCombo = 0;
        difficulty = 1; dashCooldown = 0; parryCooldown = 0; grenadeCooldown = 0; parryActive = false;
        bloodIntensity = 0; playAreaSize = 1.0; stage = 1; enemySpawnTimer = 0;
        zoomLevel = 1.0; playAreaExpansion = 1.0; basePlayAreaSize = 1.0;
        aimAssistTarget = null;
        aimAssistStrength = 0;
        substage = 0;
        healthRegenTimer = 0;
        conversionCooldown = 0;

        healthFill.style.width = '100%';
        shieldBar.style.width = '0%';
        shieldBar.classList.remove('shield-active');
        styleMeter.textContent = styleRankings[styleLevel];
        styleFill.style.width = '0%';
        scoreDisplay.textContent = `SCORE: ${score}`;
        weaponDisplay.textContent = `${weapons[currentWeapon].name} [${weapons[currentWeapon].key}]`;
        killCount.textContent = '0'; comboCount.textContent = '0'; accuracyDisplay.textContent = '100%';
        gameContainer.style.transform = 'scale(1)';
        chromaticAberration.style.boxShadow = '';

        // Generate game code if hosting
        if (isMultiplayer && isHosting) {
            gameCode = generateGameCode();
            isHost = true;
            // In a real implementation, you would send this to a server
            console.log("Game code:", gameCode);
        }

        // Transition from menu to game with animation
        if (isMultiplayer) {
            multiplayerMenu.style.opacity = '0';
            setTimeout(() => {
                multiplayerMenu.style.display = 'none';
                gameContainer.style.display = 'block';
                setTimeout(() => {
                    gameContainer.style.opacity = '1';
                    // Add transition effect
                    const transition = document.createElement('div');
                    transition.className = 'stage-transition';
                    gameContainer.appendChild(transition);
                    setTimeout(() => gameContainer.removeChild(transition), 1500);
                }, 50);
            }, 1000);
        } else {
            mainMenu.style.opacity = '0';
            setTimeout(() => {
                mainMenu.style.display = 'none';
                gameContainer.style.display = 'block';
                setTimeout(() => {
                    gameContainer.style.opacity = '1';
                    // Add transition effect
                    const transition = document.createElement('div');
                    transition.className = 'stage-transition';
                    gameContainer.appendChild(transition);
                    setTimeout(() => gameContainer.removeChild(transition), 1500);
                }, 50);
            }, 1000);
        }

        gameActive = true;

        // Reset ability cooldowns
        dashAbility.classList.remove('cooldown');
        parryAbility.classList.remove('cooldown');
        grenadeAbility.classList.remove('cooldown');

        if (styleTimeout) clearTimeout(styleTimeout);
        startStyleDecay();
    }

    // Generate a simple game code
    function generateGameCode() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    // Enhanced update function with new features
    function update(deltaTime) {
        if (!gameActive) return;
        
        // Update camera effects
        if (cameraShake > 0) {
            cameraShake *= 0.9;
            if (cameraShake < 0.1) {
                cameraShake = 0;
                cameraOffset.x = 0;
                cameraOffset.y = 0;
                cameraZoom = 1.0;
                chromaticAberration.style.boxShadow = '';
            } else {
                cameraOffset.x = (Math.random() - 0.5) * cameraShake;
                cameraOffset.y = (Math.random() - 0.5) * cameraShake;
                cameraZoom = 1.0 - cameraShake * 0.01;
            }
        }
        
        // Check for stage progression
        checkStageProgression();
        
        // Find aim assist target
        aimAssistTarget = null;
        let closestDist = 100;
        for (const enemy of enemies) {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 150 && dist < closestDist) {
                const enemyAngle = Math.atan2(dy, dx);
                let angleDiff = Math.abs(player.rotation - enemyAngle);
                angleDiff = Math.min(angleDiff, Math.PI*2 - angleDiff);
                if (angleDiff < 0.5) {
                    closestDist = dist;
                    aimAssistTarget = enemy;
                    aimAssistStrength = 0.5 * (1 - dist/150);
                }
            }
        }
        
        // Update player
        player.update(deltaTime);
        
        // Spawn enemies
        spawnEnemy(deltaTime);
        
        // Update enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            e.update(deltaTime);
            if (e.health <= 0) enemies.splice(i,1);
        }
        
        // Update allies
        for (let i = playerAllies.length - 1; i >= 0; i--) {
            if (playerAllies[i].update(deltaTime)) {
                playerAllies.splice(i,1);
            }
        }
        
        // Update obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            obstacles[i].update();
            // Check collision with player
            const o = obstacles[i];
            if (player.x + player.radius > o.x && 
                player.x - player.radius < o.x + o.width &&
                player.y + player.radius > o.y &&
                player.y - player.radius < o.y + o.height) {
                // Simple collision response - push player out
                const centerX = o.x + o.width/2;
                const centerY = o.y + o.height/2;
                const dx = player.x - centerX;
                const dy = player.y - centerY;
                const angle = Math.atan2(dy, dx);
                
                player.x = centerX + Math.cos(angle) * (o.width/2 + o.height/2 + player.radius);
                player.y = centerY + Math.sin(angle) * (o.width/2 + o.height/2 + player.radius);
                
                // Small damage
                player.takeDamage(0.5);
            }
        }
        
        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            if (b.update()) { bullets.splice(i,1); continue; }
            // Collision with enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
                const en = enemies[j];
                const dx = b.x - en.x, dy = b.y - en.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.radius + en.radius) {
                    shotsHit++; updateAccuracy();
                    if (en.takeDamage(b.damage)) enemies.splice(j,1);
                    if (!b.pierce) {
                        bullets.splice(i,1);
                        break;
                    }
                }
            }
            // Collision with obstacles
            for (const obstacle of obstacles) {
                if (b.x > obstacle.x && b.x < obstacle.x + obstacle.width &&
                    b.y > obstacle.y && b.y < obstacle.y + obstacle.height) {
                    bullets.splice(i,1);
                    break;
                }
            }
        }
        
        // Update grenades
        for (let i = grenades.length - 1; i >= 0; i--) {
            if (grenades[i].update(deltaTime)) grenades.splice(i,1);
        }
        
        // Update blood drops
        for (let i = bloodDrops.length - 1; i >= 0; i--) {
            if (bloodDrops[i].update()) bloodDrops.splice(i,1);
        }
        
        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
            if (particles[i].update()) particles.splice(i,1);
        }
        
        // Update explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
            explosions[i].life -= deltaTime;
            if (explosions[i].life <= 0) explosions.splice(i,1);
        }
        
        // Update cooldowns
        if (dashCooldown > 0) { 
            dashCooldown -= deltaTime; 
            dashAbility.classList.toggle('cooldown', dashCooldown > 0);
            if (dashCooldown <= 0) dashAbility.classList.add('ready');
        } else {
            dashAbility.classList.remove('ready');
        }
        
        if (parryCooldown > 0) { 
            parryCooldown -= deltaTime; 
            parryAbility.classList.toggle('cooldown', parryCooldown > 0);
            if (parryCooldown <= 0) parryAbility.classList.add('ready');
        } else {
            parryAbility.classList.remove('ready');
        }
        
        if (grenadeCooldown > 0) { 
            grenadeCooldown -= deltaTime; 
            grenadeAbility.classList.toggle('cooldown', grenadeCooldown > 0);
            if (grenadeCooldown <= 0) grenadeAbility.classList.add('ready');
        } else {
            grenadeAbility.classList.remove('ready');
        }
        
        // Update conversion cooldown
        if (conversionCooldown > 0) {
            conversionCooldown -= deltaTime;
        }
        
        // Decay blood intensity
        if (bloodIntensity > 0) {
            bloodIntensity = Math.max(bloodIntensity - 0.01, 0);
            bloodOverlay.style.opacity = bloodIntensity;
        }
        
        // Update crosshair position
        updateCrosshair();
        
        // Update play area expansion
        updatePlayAreaExpansion();
    }

    // Check for stage progression and activate substages
    function checkStageProgression() {
        // Advance to stage 2 at 5000 points
        if (score >= 5000 && stage === 1 && !stageTransitionActive) {
            stage = 2;
            stageTransitionActive = true;
            activateSubstage(1);
            
            // Visual transition
            const transition = document.createElement('div');
            transition.className = 'stage-transition';
            gameContainer.appendChild(transition);
            setTimeout(() => {
                gameContainer.removeChild(transition);
                stageTransitionActive = false;
            }, 1500);
        }
        
        // Advance to stage 3 at 15000 points
        if (score >= 15000 && stage === 2 && !stageTransitionActive) {
            stage = 3;
            stageTransitionActive = true;
            activateSubstage(2);
            
            // Visual transition
            const transition = document.createElement('div');
            transition.className = 'stage-transition';
            gameContainer.appendChild(transition);
            setTimeout(() => {
                gameContainer.removeChild(transition);
                stageTransitionActive = false;
            }, 1500);
        }
    }

    // Activate substage with appropriate buffs
    function activateSubstage(substageLevel) {
        substage = substageLevel;
        
        if (substageLevel === 1) {
            // First substage: Double phrases, health regen, rapid shotgun
            styleRankings.forEach((_, i) => {
                styleThresholds[i] = styleThresholds[i] * 2;
            });
            
            // Add rapid shotgun to weapons
            weapons.push({
                name: "RAPID SHOTGUN", 
                key: "5", 
                damage: weapons[1].damage * 0.6, // 60% damage
                cooldown: weapons[1].cooldown * 0.5, // Faster firing
                speed: weapons[1].speed, 
                color: "#ff6600", 
                precision: 0.6, 
                pellets: weapons[1].pellets
            });
            
            // UI notification
            showNotification("SUBSTAGE 1 UNLOCKED: Health Regen & Rapid Shotgun!");
        }
        else if (substageLevel === 2) {
            // Second substage: Enemy conversion ability
            conversionCooldown = 0; // Ready to use
            
            // Add obstacles to the game
            spawnInitialObstacles();
            
            // UI notification
            showNotification("SUBSTAGE 2 UNLOCKED: Enemy Conversion & Obstacles!");
        }
    }

    // Spawn initial obstacles
    function spawnInitialObstacles() {
        const bounds = getPlayAreaBounds();
        const obstacleCount = 5 + Math.floor(Math.random() * 5);
        
        for (let i = 0; i < obstacleCount; i++) {
            const width = 40 + Math.random() * 60;
            const height = 40 + Math.random() * 60;
            const x = bounds.minX + Math.random() * (bounds.maxX - bounds.minX - width);
            const y = bounds.minY + Math.random() * (bounds.maxY - bounds.minY - height);
            
            obstacles.push(new Obstacle(x, y, width, height));
        }
    }

    // Convert enemy to ally
    function convertEnemy() {
        if (conversionCooldown > 0 || enemies.length === 0) return;
        
        // Find closest enemy
        let closestEnemy = null;
        let closestDist = Infinity;
        
        for (const enemy of enemies) {
            const dist = distance(player.x, player.y, enemy.x, enemy.y);
            if (dist < 200 && dist < closestDist) {
                closestDist = dist;
                closestEnemy = enemy;
            }
        }
        
        if (closestEnemy) {
            // Remove enemy and create ally
            const index = enemies.indexOf(closestEnemy);
            if (index !== -1) {
                enemies.splice(index, 1);
                playerAllies.push(new Ally(closestEnemy));
                
                // Visual effect
                const conversionEffect = document.createElement('div');
                conversionEffect.className = 'conversion-effect';
                conversionEffect.style.left = (closestEnemy.x - 30) + 'px';
                conversionEffect.style.top = (closestEnemy.y - 30) + 'px';
                gameContainer.appendChild(conversionEffect);
                setTimeout(() => gameContainer.removeChild(conversionEffect), 1500);
                
                // Set cooldown
                conversionCooldown = 10; // 10 second cooldown
                
                increaseStyle(5);
            }
        }
    }

    // Update play area expansion based on kills and stage
    function updatePlayAreaExpansion() {
        // Base expansion from stage
        const stageExpansion = 1.0 + (stage * 0.2);
        
        // Additional expansion from kills
        const killExpansion = 1.0 + (kills * 0.002);
        
        // Combined expansion
        playAreaExpansion = stageExpansion * killExpansion;
        
        // Update zoom level
        zoomLevel = Math.max(0.4, 1.0 - (playAreaExpansion * 0.1));
        gameContainer.style.transform = `scale(${zoomLevel})`;
    }

    // Show notification message
    function showNotification(message) {
        const notification = document.createElement('div');
        notification.style.position = 'absolute';
        notification.style.top = '50%';
        notification.style.left = '50%';
        notification.style.transform = 'translate(-50%, -50%)';
        notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        notification.style.color = '#ff003c';
        notification.style.padding = '15px 30px';
        notification.style.border = '2px solid #ff003c';
        notification.style.borderRadius = '5px';
        notification.style.zIndex = '100';
        notification.style.fontSize = '24px';
        notification.style.textAlign = 'center';
        notification.textContent = message;
        
        gameContainer.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 1s';
            setTimeout(() => {
                if (gameContainer.contains(notification)) {
                    gameContainer.removeChild(notification);
                }
            }, 1000);
        }, 3000);
    }

    // Add new input handling for conversion ability
    window.addEventListener('keydown', (e)=>{
        keys[e.code] = true;
        if (e.code === 'Digit1') switchWeapon(0);
        if (e.code === 'Digit2') switchWeapon(1);
        if (e.code === 'Digit3') switchWeapon(2);
        if (e.code === 'Digit4') switchWeapon(3);
        if (e.code === 'Digit5' && weapons.length > 4) switchWeapon(4); // Rapid shotgun
        if (e.code === 'ShiftLeft' && gameActive && player) player.dash();
        if (e.code === 'KeyE' && gameActive && player) player.parry();
        if (e.code === 'KeyQ' && gameActive && player) player.throwGrenade();
        if (e.code === 'KeyF' && gameActive && substage >= 2) convertEnemy(); // Conversion ability
    });

    // Multiplayer menu event handlers
    hostButton.addEventListener('click', ()=>{
        multiplayerMenu.style.display = 'flex';
        document.getElementById('host-panel').style.display = 'block';
        document.getElementById('join-panel').style.display = 'none';
    });
    
    joinButton.addEventListener('click', ()=>{
        multiplayerMenu.style.display = 'flex';
        document.getElementById('host-panel').style.display = 'none';
        document.getElementById('join-panel').style.display = 'block';
    });
    
    document.getElementById('switch-to-join').addEventListener('click', ()=>{
        document.getElementById('host-panel').style.display = 'none';
        document.getElementById('join-panel').style.display = 'block';
    });
    
    document.getElementById('switch-to-host').addEventListener('click', ()=>{
        document.getElementById('host-panel').style.display = 'block';
        document.getElementById('join-panel').style.display = 'none';
    });
    
    document.getElementById('multiplayer-back').addEventListener('click', ()=>{
        multiplayerMenu.style.display = 'none';
    });
    
    document.getElementById('create-game-btn').addEventListener('click', ()=>{
        initSettings();
        initGame(true, true);
    });
    
    document.getElementById('join-game-btn').addEventListener('click', ()=>{
        const code = document.getElementById('game-code-input').value;
        if (code && code.length === 6) {
            initSettings();
            initGame(true, false);
        } else {
            alert("Please enter a valid 6-character game code");
        }
    });

    // Initialize the game
    simulateLoading();
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
