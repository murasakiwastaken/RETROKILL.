<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RETROKILL — Remaster</title>
<style>
/* ------------------------------
   GLOBAL / LAYOUT
   ------------------------------ */
:root{
  --accent:#ff003c;
  --accent2:#ffcc00;
  --bg:#070712;
  --glass: rgba(0,0,0,0.45);
  --mono: "Courier New", monospace;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#05050a 0%, #0a0812 80%);font-family:var(--mono);-webkit-font-smoothing:antialiased}
body{display:flex;align-items:center;justify-content:center;overflow:hidden}

/* Container */
#game-container{
  width: 900px;
  height: 650px;
  border-radius:12px;
  overflow:hidden;
  position:relative;
  box-shadow:0 30px 80px rgba(0,0,0,0.75), 0 0 40px rgba(255,0,60,0.06);
  background: radial-gradient(1200px 500px at 10% 20%, rgba(255,0,60,0.03), transparent 6%),
              linear-gradient(180deg,#0b0b14 0%, #0a0914 100%);
  transform: translateZ(0);
}

/* Main canvas */
canvas{display:block;width:100%;height:100%;image-rendering:pixelated;}

/* UI layer */
.ui {
  position:absolute; inset:12px; pointer-events:none;
  display:flex; flex-direction:column; justify-content:space-between;
}

.topbar { display:flex; justify-content:space-between; gap:12px; align-items:center; pointer-events:none; }
.health-bar { width:260px; height:22px; background:#12060a; border:2px solid rgba(255,0,60,0.22); border-radius:10px; overflow:hidden }
#health-fill { height:100%; width:100%; background: linear-gradient(90deg,#ff003c,#ff4466); box-shadow:0 0 12px rgba(255,0,60,0.3); transition:width 220ms linear; }
.center-hud { display:flex; flex-direction:column; align-items:center; gap:6px; pointer-events:none; }
.style-meter { font-weight:bold; color:#fff; text-shadow:0 0 8px rgba(255,0,60,0.35); letter-spacing:1px; font-size:18px }
.style-bar { width:260px; height:10px; border-radius:6px; background:#0f0f13; border:1px solid rgba(255,0,60,0.16); overflow:hidden }
#style-fill { width:0%; height:100%; background:linear-gradient(90deg,#00ccff,#ff00ff); transition:width 380ms ease-out }

/* HUD right */
.right-hud { display:flex; gap:12px; align-items:center; pointer-events:none }
.score { color:#fff; font-weight:700; letter-spacing:1px; text-shadow:0 0 8px rgba(255,0,60,0.18) }

/* bottom HUD */
.bottombar { display:flex; justify-content:space-between; align-items:flex-end; gap:12px; pointer-events:none }
.stats-card { background:var(--glass); padding:8px 10px; border-radius:8px; border:1px solid rgba(255,0,60,0.12); color:#fff; font-size:13px; text-shadow:0 0 6px rgba(0,0,0,0.6) }

/* Abilities */
.abilities { display:flex; gap:10px; pointer-events:none }
.ability { width:46px;height:46px;border-radius:8px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,0,60,0.12);display:flex;align-items:center;justify-content:center;font-size:11px;color:#fff; }

/* Crosshair styling */
.crosshair-debug { position:absolute; pointer-events:none; left:0; top:0; width:100%; height:100%; mix-blend-mode:screen; z-index:20 }

/* Overlays */
.vignette { position:absolute; inset:0; pointer-events:none; box-shadow: inset 0 0 200px rgba(0,0,0,0.85); z-index:6 }
.scanlines { position:absolute; inset:0; background-image: linear-gradient(to bottom, rgba(255,0,80,0.02) 50%, transparent 50%); background-size:100% 4px; opacity:0.07; pointer-events:none }

/* START MENU (big) */
.menu {
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:25;
  background:linear-gradient(180deg, rgba(0,0,0,0.28), rgba(0,0,0,0.4));
  backdrop-filter: blur(3px);
}
.menu-inner { text-align:center; color:#fff; pointer-events:auto; }
.title {
  font-size:72px; letter-spacing:6px; color:var(--accent); text-shadow:0 0 30px rgba(255,0,60,0.25);
  display:inline-block; transform-origin:center; margin-bottom:10px;
  line-height:0.85;
}
.title .letter { display:inline-block; opacity:0; transform:translateY(20px) scale(0.96); }

/* menu buttons */
.menu-buttons { display:flex; gap:12px; margin-top:20px; justify-content:center; }
.btn { background:linear-gradient(180deg, rgba(255,0,60,0.14), rgba(255,0,60,0.08)); color:#fff; padding:12px 22px; border-radius:10px; border:2px solid rgba(255,0,60,0.18); cursor:pointer; font-weight:700; letter-spacing:1px; transition:transform 160ms, box-shadow 160ms; }
.btn:hover { transform:translateY(-4px); box-shadow:0 10px 30px rgba(255,0,60,0.06) }

/* Guide */
.guide { display:none; position:absolute; inset:0; z-index:30; padding:20px; overflow:auto; background:rgba(0,0,0,0.85); color:#fff }

/* Game over screen */
.game-over {
  position:absolute; inset:0; z-index:40; display:flex; align-items:center; justify-content:center; pointer-events:auto;
  background:linear-gradient(180deg, rgba(0,0,0,0.8), rgba(5,0,0,0.9));
  opacity:0; transform:scale(0.98) translateY(8px); transition:all 420ms cubic-bezier(.16,.84,.24,1);
  visibility:hidden;
}
.game-over.show { opacity:1; transform:scale(1) translateY(0); visibility:visible }
.over-card { width:640px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; padding:22px; border:2px solid rgba(255,0,60,0.12); color:#fff; text-align:center }
.over-title { font-size:48px; color:var(--accent); margin-bottom:8px; text-shadow:0 0 24px rgba(255,0,60,0.12); letter-spacing:4px; }

/* stats row */
.stats-row { display:flex; justify-content:space-around; gap:12px; margin-top:16px; }
.stat { flex:1; background:rgba(0,0,0,0.25); padding:12px; border-radius:8px; border:1px solid rgba(255,0,60,0.06) }
.stat .value { font-size:26px; font-weight:800; color:#fff; }
.stat .label { font-size:12px; color:#ddd; margin-top:6px; }

/* letter-by-letter text */
.typewriter { display:inline-block; white-space:pre-wrap; }

/* small helpers */
.hidden { display:none !important; }
.small { font-size:12px }
.pointer { pointer-events:auto }

/* responsiveness */
@media (max-width:980px) {
  #game-container { transform:scale(0.86) }
}
</style>
</head>
<body>
  <div id="game-container" role="application" aria-label="RETROKILL remaster">
    <!-- Main canvas stack: world, bloom/trails, ui overlays -->
    <canvas id="game-canvas" width="900" height="650"></canvas>

    <!-- UI -->
    <div class="ui" aria-hidden="false">
      <div class="topbar">
        <div class="health-bar" aria-hidden="true"><div id="health-fill"></div></div>
        <div class="center-hud">
          <div id="style-meter" class="style-meter">DESTRUCTIVE</div>
          <div class="style-bar"><div id="style-fill"></div></div>
        </div>
        <div class="right-hud">
          <div class="score" id="score">SCORE: 0</div>
        </div>
      </div>

      <div class="bottombar">
        <div class="stats-card">
          <div>KILLS: <span id="kill-count">0</span></div>
          <div>COMBO: <span id="combo-count">0</span>x</div>
          <div>ACCURACY: <span id="accuracy">100%</span></div>
        </div>

        <div class="abilities">
          <div class="ability" id="dash-ability">DASH<br><span class="small">SHIFT</span></div>
          <div class="ability" id="parry-ability">PARRY<br><span class="small">E</span></div>
        </div>
      </div>
    </div>

    <!-- decorative overlays -->
    <div class="vignette"></div>
    <div class="scanlines"></div>

    <!-- crosshair debug layer -->
    <div class="crosshair-debug" id="crosshair-layer"></div>

    <!-- Start menu -->
    <div class="menu pointer" id="menu">
      <div class="menu-inner">
        <div class="title" id="title">RETROKILL</div>
        <div id="subtitle" style="color:#fff;opacity:0.9;margin-top:6px">A tiny HTML challenge — now remastered</div>
        <div class="menu-buttons" style="margin-top:18px;">
          <button class="btn pointer" id="play-button">START RUN</button>
          <button class="btn pointer" id="guide-button">GUIDEBOOK</button>
        </div>
        <div style="margin-top:14px;color:#ddd;font-size:13px">WASD move • Click to shoot • SHIFT dash • E parry • 1-3 switch</div>
      </div>
    </div>

    <!-- Guide -->
    <div class="guide" id="guide" aria-hidden="true">
      <button id="guide-back" class="btn pointer" style="margin-bottom:14px">BACK</button>
      <h2 style="color:var(--accent); margin-top:0">GUIDEBOOK</h2>
      <p style="color:#ddd;max-width:820px">Enemies: FILTH (weak), SCHISM (tanky), IDOL (buff auras). Use parry to reflect projectiles and earn style.</p>
    </div>

    <!-- Game over overlay -->
    <div class="game-over" id="game-over" role="dialog" aria-hidden="true">
      <div class="over-card" id="over-card">
        <div class="over-title">
          <span class="typewriter" id="over-title-typed"></span>
        </div>

        <div style="margin-top:6px;color:#fff; font-size:14px" id="over-subtyped"></div>

        <div class="stats-row" style="margin-top:16px">
          <div class="stat"><div class="value" id="final-score">0</div><div class="label">SCORE</div></div>
          <div class="stat"><div class="value" id="final-kills">0</div><div class="label">KILLS</div></div>
          <div class="stat"><div class="value" id="final-maxcombo">0</div><div class="label">MAX COMBO</div></div>
          <div class="stat"><div class="value" id="final-accuracy">0%</div><div class="label">ACCURACY</div></div>
        </div>

        <div style="margin-top:16px">
          <button class="btn pointer" id="restart-button">TRY AGAIN</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   REMASTERED GAME SCRIPT
   Notes: this layers improved visuals + UI/menus onto your existing gameplay
   - Typewriter / stat tweens for menu & death screen
   - Improved crosshair with target highlight & spread indicator
   - Bloom-lite: bright trails drawn to an offscreen buffer with 'lighter' composite
   - Soft shadows & radial light for muzzle flash
   - Animated start menu letters (letter-by-letter)
   ========================= */

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d', { alpha: true });

// Offscreen for bloom/trails (simple)
const bloomCanvas = document.createElement('canvas');
bloomCanvas.width = canvas.width; bloomCanvas.height = canvas.height;
const bctx = bloomCanvas.getContext('2d', { alpha: true });

// DOM refs
const menu = document.getElementById('menu');
const playButton = document.getElementById('play-button');
const guideButton = document.getElementById('guide-button');
const guide = document.getElementById('guide');
const guideBack = document.getElementById('guide-back');
const crosshairLayer = document.getElementById('crosshair-layer');
const gameOver = document.getElementById('game-over');
const overTitleTyped = document.getElementById('over-title-typed');
const overSubTyped = document.getElementById('over-subtyped');
const finalScoreEl = document.getElementById('final-score');
const finalKillsEl = document.getElementById('final-kills');
const finalComboEl = document.getElementById('final-maxcombo');
const finalAccuracyEl = document.getElementById('final-accuracy');
const restartButton = document.getElementById('restart-button');

const healthFill = document.getElementById('health-fill');
const styleMeter = document.getElementById('style-meter');
const styleFill = document.getElementById('style-fill');
const scoreDisplay = document.getElementById('score');
const killCount = document.getElementById('kill-count');
const comboCount = document.getElementById('combo-count');
const accuracyDisplay = document.getElementById('accuracy');
const dashAbility = document.getElementById('dash-ability');
const parryAbility = document.getElementById('parry-ability');

// keep original gameplay-compatible names & core systems
let gameActive = false;
let player = null, enemies = [], bullets = [], particles = [], bloodDrops = [];
let lastTime = 0, keys = {}, mouse = { x: canvas.width/2, y: canvas.height/2 }, cameraShake = 0;
let shotsFired = 0, shotsHit = 0, kills = 0, combo = 0, maxCombo = 0;
let score = 0, stylePoints = 0, styleLevel = 0;
let dashCooldown = 0, parryCooldown = 0, parryActive=false, parryTime=0;
let difficulty = 1, intensityLevel = 0;

// weapons & same data from your base, but we add spreadMeter for crosshair
const weapons = [
  { name:'REVOLVER', key:'1', damage:1, cooldown:0.2, speed:12, color:'#ffcc00', precision:0.95, spread:0.8 },
  { name:'SHOTGUN', key:'2', damage:3, cooldown:0.8, speed:8, color:'#ff3300', precision:0.7, pellets:5, spread:2.4 },
  { name:'NAILGUN', key:'3', damage:0.5, cooldown:0.1, speed:10, color:'#00ccff', precision:0.85, spread:1.2 }
];
let currentWeapon = 0;

/* -----------------------
   Utilities & easing
   ----------------------- */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1-t,3); }
function now(){ return performance.now(); }

/* -----------------------
   Typing / letter by letter helper
   - returns a promise that resolves after typing finishes
   ----------------------- */
function typeToElement(el, text, speed=28) {
  el.textContent = '';
  return new Promise(resolve=>{
    let i=0;
    const tick = ()=>{
      if (i <= text.length) {
        el.textContent = text.slice(0,i);
        i++;
        setTimeout(tick, speed * (0.9 + Math.random()*0.25));
      } else { resolve(); }
    };
    tick();
  });
}

/* -----------------------
   Number tween for stats
   ----------------------- */
function animateNumber(el, from, to, duration=900, fmt = (v)=>Math.round(v)) {
  const start = now(), end = start + duration;
  return new Promise(resolve=>{
    (function tick(){
      const t = clamp((now()-start)/duration,0,1);
      const v = from + (to-from) * easeOutCubic(t);
      el.textContent = fmt(v);
      if (t < 1) requestAnimationFrame(tick);
      else resolve();
    })();
  });
}

/* -----------------------
   Enhanced visuals: bloom & dynamic light
   We'll render main world to ctx, bright elements to bctx with 'lighter'
   At end we'll composite bloom back with alpha and blur-ish scaling
   ----------------------- */
function applyBloom() {
  // simple blur by drawing scaled and faded multiple times
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.globalAlpha = 0.25;
  // draw the bloom buffer several times slightly scaled to create soft glow
  ctx.drawImage(bloomCanvas, -2, -2, canvas.width+4, canvas.height+4);
  ctx.globalAlpha = 0.12;
  ctx.drawImage(bloomCanvas, -6, -6, canvas.width+12, canvas.height+12);
  ctx.globalAlpha = 1;
  ctx.restore();
  // clear bloom buffer for next frame
  bctx.clearRect(0,0,bloomCanvas.width,bloomCanvas.height);
}

/* -----------------------
   Enhanced crosshair (DOM canvas overlay)
   - visible reticle + spread ring + highlighted enemy under cursor + distance readout
   ----------------------- */
function drawCrosshairOverlay() {
  const el = crosshairLayer;
  const pixelRatio = 1;
  // clear & draw using inline SVG approach for crispness
  // We'll produce a small canvas and set as background-image for the overlay to keep it efficient.
  const cw = canvas.width, ch=canvas.height;
  const c = document.createElement('canvas');
  c.width = cw; c.height = ch;
  const k = c.getContext('2d');
  k.clearRect(0,0,cw,ch);

  // compute current weapon spread visual
  const w = weapons[currentWeapon];
  const movementSpread = ( (keys['KeyW']||keys['KeyS']||keys['KeyA']||keys['KeyD']) ? 1.2 : 0.6 );
  const baseSpread = (w.spread || 1) * movementSpread;
  const spreadPx = 8 + baseSpread * 6;

  // find enemy under crosshair
  let target = null, tdist = Infinity;
  for (const e of enemies) {
    const dx = e.x - mouse.x, dy = e.y - mouse.y; const d = Math.hypot(dx,dy);
    if (d < e.radius + 12 && d < tdist) { target = e; tdist = d; }
  }

  // reticle glow
  k.save();
  k.translate(mouse.x, mouse.y);
  k.globalCompositeOperation = 'lighter';
  k.beginPath();
  k.arc(0,0,14,0,Math.PI*2);
  k.fillStyle = 'rgba(255,204,0,0.06)'; k.fill();
  k.closePath();
  k.globalCompositeOperation = 'source-over';

  // center cross
  k.strokeStyle = '#ffcc00'; k.lineWidth = 2;
  k.beginPath();
  k.moveTo(-14,0); k.lineTo(-6,0);
  k.moveTo(14,0); k.lineTo(6,0);
  k.moveTo(0,-14); k.lineTo(0,-6);
  k.moveTo(0,14); k.lineTo(0,6);
  k.stroke();

  // spread ring
  k.beginPath();
  k.lineWidth = 1.5;
  k.strokeStyle = 'rgba(255,255,255,0.14)';
  k.setLineDash([6,6]);
  k.arc(0,0,spreadPx,0,Math.PI*2);
  k.stroke();
  k.setLineDash([]);

  // highlight if target
  if (target) {
    k.beginPath();
    k.strokeStyle = '#00ff66';
    k.lineWidth = 2.5;
    k.arc(0,0,target.radius + 6, 0, Math.PI*2);
    k.stroke();
    // distance text
    k.font = '14px ' + getComputedStyle(document.body).fontFamily;
    k.fillStyle = 'rgba(255,255,255,0.95)';
    k.fillText(`${Math.round(tdist)} px`, 18, -4);
  }

  k.restore();

  el.style.backgroundImage = `url(${c.toDataURL()})`;
}

/* -----------------------
   Graphics: world draw helpers
   - softShadow, muzzle flash radial light, floor grid
   ----------------------- */
function drawSoftShadow(x,y,r,alpha=0.25) {
  const g = ctx.createRadialGradient(x,y,r*0.1,x,y,r);
  g.addColorStop(0, `rgba(0,0,0,${alpha})`);
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
}

/* -----------------------
   Game objects (kept similar to your original but improved rendering)
   ----------------------- */
class Player {
  constructor(){
    this.x = canvas.width/2; this.y = canvas.height/2;
    this.radius = 20; this.speed = 5; this.health = 100; this.maxHealth = 100;
    this.rotation = 0; this.shootCooldown = 0;
    this.dashing=false; this.dashTime=0; this.dashDuration=0.18;
  }
  update(dt){
    if (this.dashing){ this.dashTime -= dt; if (this.dashTime<=0) this.dashing=false; }
    let mx=0,my=0;
    if (keys['KeyW']) my -= 1;
    if (keys['KeyS']) my += 1;
    if (keys['KeyA']) mx -= 1;
    if (keys['KeyD']) mx += 1;
    if (mx!==0||my!==0){ const L=Math.hypot(mx,my)||1; mx/=L; my/=L; }
    const speed = this.dashing ? this.speed*3 : this.speed;
    this.x += mx * speed; this.y += my * speed;
    this.x = clamp(this.x, this.radius, canvas.width - this.radius);
    this.y = clamp(this.y, this.radius, canvas.height - this.radius);
    this.rotation = Math.atan2(mouse.y - this.y, mouse.x - this.x);
    if (this.shootCooldown > 0) this.shootCooldown -= dt;
    if (parryActive){
      parryTime -= dt; if (parryTime<=0) parryActive=false;
    }
  }
  draw(){
    // shadow
    drawSoftShadow(this.x, this.y+6, this.radius*1.8, 0.38);

    // slight body gradient & rim light for depth
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    // body base
    const grad = ctx.createLinearGradient(-this.radius,this.radius,this.radius,-this.radius);
    grad.addColorStop(0,'#330010'); grad.addColorStop(1,'#ff003c');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fill();

    // rim
    ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.lineWidth = 3; ctx.stroke();

    // gun stub
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.rect(this.radius-2,-6,18,12); ctx.fill();

    // muzzle glow (if recently shot)
    if (cameraShake>1){
      const g = ctx.createRadialGradient(this.radius+12,0,2,this.radius+12,0,40);
      g.addColorStop(0, 'rgba(255,204,0,0.75)'); g.addColorStop(1,'rgba(255,0,60,0)');
      ctx.fillStyle = g; ctx.beginPath(); ctx.arc(this.radius+12,0,36,0,Math.PI*2); ctx.fill();
      // also draw to bloom buffer for glow
      bctx.save();
      bctx.translate(this.x, this.y);
      bctx.rotate(this.rotation);
      bctx.fillStyle = 'rgba(255,180,20,0.6)';
      bctx.beginPath(); bctx.arc(this.radius+12,0,26,0,Math.PI*2); bctx.fill();
      bctx.restore();
    }

    // parry aura
    if (parryActive){
      ctx.beginPath();
      ctx.arc(0,0,this.radius+10,0,Math.PI*2);
      ctx.fillStyle = 'rgba(0,255,100,0.08)';
      ctx.fill();
    }
    ctx.restore();
  }
  shoot(){
    if (this.shootCooldown > 0) return;
    const w = weapons[currentWeapon];
    this.shootCooldown = w.cooldown;
    shotsFired++; updateAccuracy();

    const base = this.rotation;
    if (w.name === 'SHOTGUN'){
      for (let i=0;i<w.pellets;i++){
        const spread = (Math.random()-0.5) * (1 - w.precision) * 1.6;
        const ang = base + spread;
        bullets.push(new Bullet(this.x + Math.cos(ang)*this.radius, this.y + Math.sin(ang)*this.radius, ang, w.speed, w.color, w.damage));
      }
    } else {
      const spread = (Math.random()-0.5) * (1 - w.precision) * 0.38;
      const ang = base + spread;
      bullets.push(new Bullet(this.x + Math.cos(ang)*this.radius, this.y + Math.sin(ang)*this.radius, ang, w.speed, w.color, w.damage));
    }

    // recoil & muzzle flash particles drawn to bloom buffer
    cameraShake = Math.max(cameraShake, w.name === 'SHOTGUN' ? 9 : 5);
    for (let i=0;i<8;i++){
      particles.push(new Particle(this.x + Math.cos(base)*this.radius, this.y + Math.sin(base)*this.radius,
        (Math.cos(base + (Math.random()-0.5)*0.6) * (4+Math.random()*8)),
        (Math.sin(base + (Math.random()-0.5)*0.6) * (4+Math.random()*8)),
        w.color, 2 + Math.random()*3, 0.22 + Math.random()*0.3));
      // also bloom bright flecks
      bctx.fillStyle = w.color; bctx.globalAlpha = 0.9;
      bctx.beginPath(); bctx.arc(this.x + Math.cos(base)*this.radius, this.y + Math.sin(base)*this.radius, 3+Math.random()*4,0,Math.PI*2); bctx.fill();
      bctx.globalAlpha = 1;
    }
  }
  dash(){
    if (dashCooldown>0 || this.dashing) return;
    this.dashing=true; this.dashTime=this.dashDuration; dashCooldown = 0.55;
    // dash particles
    for (let i=0;i<20;i++){
      particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*16, (Math.random()-0.5)*16, '#00ccff', 2+Math.random()*2, 0.5));
    }
  }
  parry(){
    if (parryCooldown>0 || parryActive) return;
    parryActive = true; parryTime = 0.34; parryCooldown=1.05;
    // small reflect pulse (reflects bullets near)
    for (const b of bullets){
      const d = Math.hypot(b.x - this.x, b.y - this.y);
      if (d < this.radius + 28){
        b.angle += Math.PI; b.speed *= 1.4; b.color = '#00ff66'; increaseStyle(5);
      }
    }
  }
  takeDamage(a){
    this.health -= a; this.health = Math.max(0,this.health);
    healthFill.style.width = `${(this.health/this.maxHealth)*100}%`;
    // flash:
    const flash = document.createElement('div');
    flash.style.position='absolute'; flash.style.left='0'; flash.style.top='0';
    flash.style.right='0'; flash.style.bottom='0'; flash.style.pointerEvents='none';
    flash.style.background='rgba(255,0,60,0.14)'; flash.style.zIndex='50';
    document.getElementById('game-container').appendChild(flash);
    setTimeout(()=>{ if (flash.parentNode) flash.parentNode.removeChild(flash); }, 120);
    cameraShake = Math.max(cameraShake, 10);
    combo = 0; comboCount.textContent = combo;
    if (this.health <= 0) triggerGameOver();
  }
  heal(a){
    this.health = Math.min(this.maxHealth, this.health + a);
    healthFill.style.width = `${(this.health/this.maxHealth)*100}%`;
  }
}

class Enemy {
  constructor(x,y,type){
    this.x=x; this.y=y; this.type=type;
    this.baseSpeed = 1.5; this.buffing=false; this.attackCooldown=0;
    if (type==='FILTH'){ this.radius=15; this.speed=this.baseSpeed*1.25; this.health=3; this.color='#6666ff'; this.damage=10; this.score=100; }
    else if (type==='SCHISM'){ this.radius=24; this.speed=this.baseSpeed*2.0; this.health=8; this.color='#ff3333'; this.damage=15; this.score=200; }
    else { this.radius=20; this.speed=this.baseSpeed*1.2; this.health=5; this.color='#ffdd33'; this.damage=5; this.score=300; this.buffRadius=150; }
  }
  update(dt){
    // simple AI: move towards player unless buffing with IDOL behavior
    const dx = player.x - this.x, dy = player.y - this.y;
    let dist = Math.hypot(dx,dy) || 0.0001;
    if (this.type==='IDOL'){
      // buff neighbors if close; otherwise move slightly more slowly
      this.buffing = false;
      for (const en of enemies){
        if (en!==this && en.type!=='IDOL'){
          if (Math.hypot(en.x-this.x, en.y-this.y) < this.buffRadius) { this.buffing=true; en.speed = en.baseSpeed * 2.5 * difficulty; }
        }
      }
      if (!this.buffing){
        if (dist > 200) { this.x += (dx/dist) * this.speed * 0.6; this.y += (dy/dist) * this.speed * 0.6; }
        else if (dist < 150) { this.x -= (dx/dist) * this.speed * 0.6; this.y -= (dy/dist) * this.speed * 0.6; }
      }
    } else {
      this.speed = this.baseSpeed * (this.type==='FILTH' ? 2 * difficulty : 1.5 * difficulty);
      this.x += (dx/dist) * this.speed;
      this.y += (dy/dist) * this.speed;
    }

    if (this.attackCooldown > 0) this.attackCooldown -= dt;
    if (Math.hypot(player.x - this.x, player.y - this.y) < this.radius + player.radius && this.attackCooldown <= 0){
      player.takeDamage(this.damage);
      this.attackCooldown = 1;
    }
  }
  draw(){
    // soft shadow
    drawSoftShadow(this.x, this.y+6, this.radius*1.6, 0.28);

    ctx.save(); ctx.translate(this.x, this.y);
    // body base with inner shading
    const g = ctx.createLinearGradient(-this.radius, -this.radius, this.radius, this.radius);
    g.addColorStop(0, '#222'); g.addColorStop(1, this.color);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fill();
    // highlight ring for schism
    if (this.type === 'SCHISM'){
      ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.lineWidth = 2; ctx.stroke();
      for (let i=0;i<6;i++){
        ctx.beginPath(); ctx.moveTo(Math.cos(i/6*Math.PI*2)*(this.radius-3), Math.sin(i/6*Math.PI*2)*(this.radius-3));
        ctx.lineTo(Math.cos(i/6*Math.PI*2)*(this.radius+6), Math.sin(i/6*Math.PI*2)*(this.radius+6));
        ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth=1.6; ctx.stroke();
      }
    } else if (this.type==='IDOL' && this.buffing){
      ctx.beginPath(); ctx.arc(0,0,this.radius+6,0,Math.PI*2);
      ctx.strokeStyle = 'rgba(255,220,50,0.6)'; ctx.lineWidth = 2; ctx.setLineDash([5,4]); ctx.stroke(); ctx.setLineDash([]);
      // bloom
      bctx.fillStyle = 'rgba(255,220,50,0.12)'; bctx.beginPath(); bctx.arc(this.x,this.y,this.radius+18,0,Math.PI*2); bctx.fill();
    }
    ctx.restore();
  }
  takeDamage(amount){
    this.health -= amount;
    for (let i=0;i<10;i++){
      particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*6, (Math.random()-0.5)*6, '#ff003c', 2+Math.random()*2, 0.5+Math.random()*0.4));
      bctx.fillStyle = 'rgba(255,0,60,0.16)'; bctx.beginPath(); bctx.arc(this.x+ (Math.random()-0.5)*8, this.y + (Math.random()-0.5)*8, 2+Math.random()*3,0,Math.PI*2); bctx.fill();
    }
    if (this.health <= 0) {
      // drop blood pickups
      for (let i=0;i<6;i++) bloodDrops.push(new BloodDrop(this.x + (Math.random()-0.5)*20, this.y + (Math.random()-0.5)*20));
      const points = Math.round(this.score * (styleLevel + 1) * (combo > 0 ? combo : 1));
      score += points; scoreDisplay.textContent = `SCORE: ${score}`;
      kills++; killCount.textContent = kills;
      increaseCombo(); increaseStyle(3);
      cameraShake = Math.max(cameraShake, 8);
      return true;
    }
    return false;
  }
}

class Bullet {
  constructor(x,y,angle,speed,color,damage){
    this.x=x; this.y=y; this.angle=angle; this.speed=speed; this.color=color; this.damage=damage; this.radius=3;
  }
  update(){
    this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed;
    // trail to bloom
    bctx.fillStyle = this.color; bctx.globalAlpha = 0.18; bctx.beginPath(); bctx.arc(this.x,this.y,2,0,Math.PI*2); bctx.fill(); bctx.globalAlpha=1;
    particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*1.2, (Math.random()-0.5)*1.2, this.color, 1 + Math.random()*1.2, 0.22));
    if (this.x < -40 || this.x > canvas.width + 40 || this.y < -40 || this.y > canvas.height + 40) return true;
    return false;
  }
  draw(){
    ctx.save();
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = this.color; ctx.fill();
    ctx.globalAlpha = 0.22; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius+4, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.restore();
  }
}

class Particle {
  constructor(x,y,vx,vy,color,size,life){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.color=color; this.size=size; this.life=life; this.maxLife=life;
  }
  update(){
    this.x += this.vx; this.y += this.vy; this.life -= 0.016; this.vx *= 0.96; this.vy *= 0.96;
    return this.life <= 0;
  }
  draw(){
    const a = clamp(this.life / this.maxLife,0,1);
    ctx.save(); ctx.globalAlpha = a;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.size * a, 0, Math.PI*2);
    ctx.fillStyle = this.color; ctx.fill();
    ctx.restore();
  }
}

class BloodDrop {
  constructor(x,y){ this.x=x; this.y=y; this.radius=6; this.life=10; this.color='#ff003c'; }
  update(){
    this.life -= 0.016;
    if (this.life <= 0) return true;
    const d = Math.hypot(player.x - this.x, player.y - this.y);
    if (d < this.radius + player.radius){
      player.heal(10); increaseStyle(1);
      for (let i=0;i<6;i++) particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*3, (Math.random()-0.5)*3, '#ff003c', 1+Math.random()*2, 0.5));
      return true;
    }
    return false;
  }
  draw(){
    ctx.save();
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = this.color; ctx.fill();
    ctx.globalAlpha = 0.28; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius+4, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    ctx.restore();
  }
}

/* -----------------------
   High-level systems: style, combo, accuracy
   ----------------------- */
const styleRankings = ["DESTRUCTIVE","DISASTROUS","DEVASTATING","DISGUSTING","BLOODBATH","ULTRAKILL"];
const styleThresholds = [0,5,15,30,50,75];

function increaseStyle(amount){
  stylePoints += amount;
  let newLevel = 0;
  for (let i=styleThresholds.length-1;i>=0;i--) if (stylePoints >= styleThresholds[i]) { newLevel = i; break; }
  if (newLevel > styleLevel){
    cameraShake = Math.max(cameraShake, 12);
    styleMeter.style.textShadow = '0 0 20px #ff00ff';
    setTimeout(()=> styleMeter.style.textShadow = '0 0 8px rgba(255,0,60,0.35)', 220);
  }
  styleLevel = newLevel;
  styleMeter.textContent = styleRankings[styleLevel] || styleRankings[styleRankings.length-1];
  const nextThreshold = styleLevel < styleThresholds.length - 1 ? styleThresholds[styleLevel+1] : styleThresholds[styleLevel]*2;
  const progress = (stylePoints - styleThresholds[styleLevel]) / Math.max(1, (nextThreshold - styleThresholds[styleLevel]));
  styleFill.style.width = `${clamp(progress,0,1) * 100}%`;
  // decay
  if (this._styleDecay) clearTimeout(this._styleDecay);
  this._styleDecay = setTimeout(()=>{ stylePoints = Math.max(0, stylePoints - 0.12); startStyleDecay(); }, 120);
}
function startStyleDecay(){
  if (stylePoints <= 0) return;
  const decayRate = 0.12 / (1 + difficulty * 0.5);
  setTimeout(()=>{
    stylePoints = Math.max(0, stylePoints - decayRate);
    let newLevel = 0;
    for (let i=styleThresholds.length-1;i>=0;i--) if (stylePoints >= styleThresholds[i]) { newLevel = i; break; }
    styleLevel = newLevel;
    styleMeter.textContent = styleRankings[styleLevel];
    const nextThreshold = styleLevel < styleThresholds.length - 1 ? styleThresholds[styleLevel+1] : styleThresholds[styleLevel]*2;
    const progress = styleLevel > 0 ? (stylePoints - styleThresholds[styleLevel]) / Math.max(1, (nextThreshold - styleThresholds[styleLevel])) : stylePoints / Math.max(1, nextThreshold);
    styleFill.style.width = `${clamp(progress,0,1) * 100}%`;
    if (stylePoints > 0) startStyleDecay();
  }, 120);
}

function increaseCombo(){
  combo++; comboCount.textContent = combo; if (combo > maxCombo) maxCombo = combo;
  if (combo % 5 === 0){
    // show big combo text (small transient)
    const el = document.createElement('div'); el.textContent = `+${combo} COMBO!`;
    el.style.position = 'absolute'; el.style.left = '50%'; el.style.top = '48%';
    el.style.transform = 'translate(-50%,-50%)'; el.style.color = '#fff'; el.style.fontWeight='bold';
    el.style.zIndex = '60'; el.style.fontSize='36px'; el.style.textShadow='0 0 14px rgba(255,0,60,0.3)';
    document.getElementById('game-container').appendChild(el);
    setTimeout(()=>{ if (el.parentNode) el.parentNode.removeChild(el); }, 900);
  }
  if (this._comboT) clearTimeout(this._comboT);
  this._comboT = setTimeout(()=>{ combo=0; comboCount.textContent=0; }, 3000);
}

function updateAccuracy(){
  const acc = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 100;
  accuracyDisplay.textContent = `${acc}%`;
}

/* -----------------------
   Spawn & game flow
   ----------------------- */
function spawnEnemy(){
  if (!gameActive) return;
  difficulty = 1 + (score / 5000) + (styleLevel * 0.2);
  const r = Math.random(); let type;
  if (r < 0.6) type = 'FILTH';
  else if (r < 0.9) type = 'SCHISM';
  else type = 'IDOL';
  const side = Math.floor(Math.random()*4); let x,y;
  switch(side){
    case 0: x = Math.random()*canvas.width; y = -40; break;
    case 1: x = canvas.width + 40; y = Math.random()*canvas.height; break;
    case 2: x = Math.random()*canvas.width; y = canvas.height + 40; break;
    default: x = -40; y = Math.random()*canvas.height; break;
  }
  enemies.push(new Enemy(x,y,type));
  const next = Math.max(300, 1200 - (score/18));
  setTimeout(spawnEnemy, next);
}

/* -----------------------
   Game over & stat animations
   ----------------------- */
function triggerGameOver(){
  gameActive = false;
  // show overlay with typewriter then animate numbers
  gameOver.classList.add('show'); gameOver.setAttribute('aria-hidden', 'false');
  overTitleTyped.textContent = '';
  overSubTyped.textContent = '';
  // type and then animate stats
  (async () => {
    await typeToElement(overTitleTyped, 'MACHINE TURNED OFF', 32);
    await typeToElement(overSubTyped, `Run Ended — Final Tally`, 18);
    await animateNumber(finalScoreEl, 0, score, 900, v=>Math.round(v));
    await animateNumber(finalKillsEl, 0, kills, 700, v=>Math.round(v));
    await animateNumber(finalComboEl, 0, maxCombo, 700, v=>Math.round(v));
    await animateNumber(finalAccuracyEl, 0, shotsFired>0 ? Math.round((shotsHit/shotsFired)*100) : 100, 700, v=>`${Math.round(v)}%`);
  })();
}

/* -----------------------
   Input + bindings
   ----------------------- */
window.addEventListener('keydown', e=>{
  keys[e.code] = true;
  if (e.code === 'Digit1') switchWeapon(0);
  if (e.code === 'Digit2') switchWeapon(1);
  if (e.code === 'Digit3') switchWeapon(2);
  if (e.code === 'ShiftLeft' && gameActive && player) player.dash();
  if (e.code === 'KeyE' && gameActive && player) player.parry();
});
window.addEventListener('keyup', e => keys[e.code] = false);

canvas.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
  mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
});

canvas.addEventListener('click', e=>{
  if (gameActive && player) player.shoot();
  else if (!gameActive && menu.style.display !== 'none') startRun();
});

playButton.addEventListener('click', startRun);
guideButton.addEventListener('click', ()=>{ menu.style.display='none'; guide.style.display='block'; });
guideBack.addEventListener('click', ()=>{ guide.style.display='none'; menu.style.display='flex'; });

restartButton.addEventListener('click', ()=>{
  gameOver.classList.remove('show'); gameOver.setAttribute('aria-hidden','true');
  startRun();
});

/* -----------------------
   Weapon switch
   ----------------------- */
function switchWeapon(i){
  if (i>=0 && i<weapons.length){ currentWeapon = i; /* minor UI flash */ scoreDisplay.style.textShadow = '0 0 12px rgba(255,204,0,0.3)';
    setTimeout(()=>scoreDisplay.style.textShadow = '', 260);
  }
}

/* -----------------------
   Init / reset run
   ----------------------- */
function startRun(){
  // hide menu
  menu.style.display = 'none';
  guide.style.display = 'none';
  gameOver.classList.remove('show');
  // reset game variables
  player = new Player();
  enemies = []; bullets = []; particles = []; bloodDrops = [];
  score = 0; stylePoints = 0; styleLevel = 0; shotsFired=0; shotsHit=0; kills=0; combo=0; maxCombo=0;
  styleFill.style.width = '0%'; styleMeter.textContent = styleRankings[0];
  healthFill.style.width = '100%';
  scoreDisplay.textContent = `SCORE: ${score}`;
  killCount.textContent='0'; comboCount.textContent='0'; accuracyDisplay.textContent='100%';
  gameActive = true;
  setTimeout(spawnEnemy, 700);
  startStyleDecay();
}

/* -----------------------
   Draw world (simple floor grid + parallax stars)
   ----------------------- */
function drawBackground(t){
  // subtle moving gradient + stars parallax from style
  ctx.save();
  // floor grid
  const gridSize = 36;
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  for (let x = - (t*0.02 % gridSize); x < canvas.width; x += gridSize){
    ctx.beginPath(); ctx.moveTo(x, canvas.height*0.62); ctx.lineTo(x+gridSize, canvas.height*0.62+6); ctx.stroke();
  }
  // horizon gradient
  const hg = ctx.createLinearGradient(0,0,0,canvas.height);
  hg.addColorStop(0,'rgba(255,0,60,0.02)'); hg.addColorStop(0.7,'rgba(0,0,0,0)'); ctx.fillStyle = hg;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();
}

/* -----------------------
   Main loop
   ----------------------- */
function gameLoop(ts){
  if (!lastTime) lastTime = ts;
  const dt = clamp((ts - lastTime)/1000, 0, 0.05);
  lastTime = ts;

  // decay camera shake
  if (cameraShake > 0) { cameraShake *= 0.86; if (cameraShake < 0.3) cameraShake = 0; }
  if (dashCooldown > 0) { dashCooldown -= dt; dashAbility.classList.toggle('cooldown', dashCooldown>0); }
  if (parryCooldown > 0) { parryCooldown -= dt; parryAbility.classList.toggle('cooldown', parryCooldown>0); }

  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  bctx.clearRect(0,0,bloomCanvas.width,bloomCanvas.height);

  // world
  drawBackground(ts);

  // update & draw enemies
  if (gameActive) {
    player.update(dt);
    for (let i = enemies.length - 1; i >= 0; i--){
      const e = enemies[i]; e.update(dt); e.draw();
    }

    // bullets
    for (let i = bullets.length - 1; i >= 0; i--){
      const b = bullets[i];
      if (b.update()){ bullets.splice(i,1); continue; }
      // collision with enemies
      for (let j = enemies.length - 1; j >= 0; j--){
        const en = enemies[j];
        const dx = b.x - en.x, dy = b.y - en.y;
        const d = Math.hypot(dx,dy);
        if (d < b.radius + en.radius){
          shotsHit++; updateAccuracy();
          // small hit bloom
          bctx.fillStyle = 'rgba(255,220,20,0.16)'; bctx.beginPath(); bctx.arc(b.x,b.y,8,0,Math.PI*2); bctx.fill();
          if (en.takeDamage(b.damage)) enemies.splice(j,1);
          bullets.splice(i,1); break;
        }
      }
      if (i < bullets.length) b.draw();
    }

    // blood drops
    for (let i = bloodDrops.length - 1; i >= 0; i--){
      if (bloodDrops[i].update()) { bloodDrops.splice(i,1); continue; }
      bloodDrops[i].draw();
    }

    // particles
    for (let i = particles.length - 1; i >= 0; i--){
      if (particles[i].update()) { particles.splice(i,1); continue; }
      particles[i].draw();
    }

    player.draw();
    // UI overlays
    updateIntensity();
    drawCrosshairOverlay();

  } else {
    // idle menu floats
    drawCrosshairOverlay();
  }

  // composite bloom from bctx onto ctx with soft draws
  applyBloom();

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* -----------------------
   Intensity (small reactionary overlay)
   ----------------------- */
function updateIntensity(){
  intensityLevel = clamp(0.18 * styleLevel + 0.09 * combo + 0.05 * enemies.length, 0, 1);
  // set subtle CSS effect: adjust body vignette intensity (we already have strong vignette in CSS)
}

/* -----------------------
   Small helpers: show animated title on menu
   ----------------------- */
(function animateMenuTitle(){
  const title = document.getElementById('title');
  const t = title.textContent.trim();
  title.innerHTML = '';
  // create letters
  for (let i=0;i<t.length;i++){
    const s = document.createElement('span'); s.className = 'letter'; s.textContent = t[i]; title.appendChild(s);
  }
  // stagger entrance
  const letters = title.querySelectorAll('.letter');
  let idx = 0;
  const interval = setInterval(()=>{
    if (idx >= letters.length) { clearInterval(interval); return; }
    const el = letters[idx++];
    el.style.opacity = '1';
    el.style.transform = 'translateY(0) scale(1)';
    el.style.transition = 'all 420ms cubic-bezier(.16,.84,.24,1)';
  }, 70);
})();

/* -----------------------
   Minimal safety & initial focus
   ----------------------- */
// When the page loads show the menu (we already have it visible)
menu.style.display = 'flex';
</script>
</body>
</html>
