<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>RETROKILL: Remastered</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html,body { height:100%; overflow: hidden; font-family: 'VT323', monospace; }
        body {
            background-color: #000;
            color: #ff003c;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            cursor: none;
            image-rendering: pixelated;
            position: relative;
            overflow: hidden;
        }

        /* CRT effect */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            animation: crtFlicker 0.15s infinite;
        }

        @keyframes crtFlicker {
            0% { opacity: 0.9; }
            5% { opacity: 0.8; }
            10% { opacity: 0.85; }
            15% { opacity: 0.9; }
            20% { opacity: 0.95; }
            25% { opacity: 0.85; }
            30% { opacity: 0.95; }
            35% { opacity: 0.85; }
            40% { opacity: 0.8; }
            45% { opacity: 0.9; }
            50% { opacity: 0.85; }
            55% { opacity: 0.8; }
            60% { opacity: 0.75; }
            65% { opacity: 0.7; }
            70% { opacity: 0.8; }
            75% { opacity: 0.85; }
            80% { opacity: 0.9; }
            85% { opacity: 0.95; }
            90% { opacity: 0.9; }
            95% { opacity: 0.85; }
            100% { opacity: 0.9; }
        }

        /* Loading screen */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading-text {
            font-size: 24px;
            color: #ff003c;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 1.5s infinite alternate;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
        }

        @keyframes pulse {
            from { text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 0 5px #ff003c; }
            to { text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 0 20px #ff003c, 0 0 30px #ff003c; }
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: #222;
            border: 2px solid #ff003c;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.5);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff003c, #ff3366);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ff003c;
        }

        /* Main menu */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #20000d 0%, #0a0005 100%);
            display: flex;
            z-index: 900;
            transition: opacity 1s ease;
        }

        .menu-background {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .menu-background canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.3;
            filter: blur(2px) contrast(1.2);
        }

        .menu-content {
            width: 400px;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-left: 4px solid #ff003c;
            box-shadow: -10px 0 30px rgba(255, 0, 60, 0.3);
        }

        .title {
            font-size: 60px;
            color: #ff003c;
            margin-bottom: 40px;
            letter-spacing: 8px;
            text-transform: uppercase;
            position: relative;
            animation: titleGlow 2s infinite alternate;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            font-style: italic;
        }

        @keyframes titleGlow {
            from { text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 0 20px #ff003c; }
            to { text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 0 30px #ff003c, 0 0 40px #ff003c, 0 0 50px #ff003c; }
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
            width: 100%;
        }

        .menu-option {
            padding: 12px 20px;
            background: rgba(255, 0, 60, 0.2);
            color: #fff;
            border: 2px solid #ff003c;
            border-radius: 5px;
            font-size: 24px;
            text-align: center;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        .menu-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .menu-option:hover {
            background: rgba(255, 0, 60, 0.4);
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff003c;
        }

        .menu-option:hover::before {
            left: 100%;
        }

        .settings-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff003c;
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            width: 100%;
            animation: fadeIn 0.5s ease;
            display: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-label {
            color: #fff;
            margin-bottom: 5px;
            display: block;
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        .slider {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            background: #333;
            outline: none;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(255, 0, 60, 0.5);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff003c;
            cursor: pointer;
            box-shadow: 0 0 10px #ff003c;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px #ff003c;
        }

        /* Game container */
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 4px solid #ff003c;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 30px #ff003c;
            background: #0a0a0a;
            transform-origin: center center;
            transition: transform 0.5s ease;
            display: none;
        }

        canvas { 
            width:100%; 
            height:100%; 
            display:block; 
            image-rendering: pixelated; 
        }

        /* Post-processing effects */
        #effects-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .chromatic-aberration {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            mix-blend-mode: overlay;
            z-index: 51;
            opacity: 0.1;
            pointer-events: none;
        }

        .pixelation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            z-index: 52;
            pointer-events: none;
        }

        /* UI elements */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
        }

        .health-bar { 
            width: 200px; 
            height: 20px; 
            background-color: #330000; 
            border: 2px solid #ff003c; 
            border-radius: 10px; 
            overflow: hidden; 
            position: relative;
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.5);
        }
        
        #health-fill { 
            height:100%; 
            width:100%; 
            background: linear-gradient(90deg, #ff003c, #ff3366); 
            transition: width 0.2s ease; 
            position: relative;
        }

        #health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: healthShine 2s infinite;
        }

        @keyframes healthShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #shield-bar {
            position: absolute;
            top: -5px;
            left: 0;
            height: 5px;
            width: 100%;
            background: linear-gradient(90deg, #00ccff, #0066ff);
            border-radius: 5px 5px 0 0;
            transition: width 0.2s ease;
            box-shadow: 0 0 5px #00ccff;
        }

        #style-container { 
            display:flex; 
            flex-direction:column; 
            align-items:center; 
        }
        
        #style-meter { 
            font-size: 20px; 
            font-weight: bold; 
            color:#fff; 
            letter-spacing:1px; 
            animation: stylePulse 1s infinite alternate;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            font-style: italic;
        }

        @keyframes stylePulse {
            from { text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 0 8px #ff003c; }
            to { text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 0 0 15px #ff003c, 0 0 20px #ff003c; }
        }
        
        #style-bar { 
            width:200px; 
            height:10px; 
            background: #222; 
            border:1px solid #ff003c; 
            border-radius:5px; 
            overflow:hidden; 
            margin-top:6px; 
            box-shadow: 0 0 5px rgba(255, 0, 60, 0.5);
        }
        
        #style-fill { 
            height:100%; 
            width:0%; 
            background: linear-gradient(90deg, #ff003c, #ff00ff); 
            transition: width 0.2s ease; 
            position: relative;
        }

        #style-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: styleShine 1.5s infinite;
        }

        @keyframes styleShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #score { 
            font-size: 18px; 
            color:#fff; 
            animation: scoreGlitch 3s infinite alternate;
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        @keyframes scoreGlitch {
            0% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-2px); }
            20% { transform: translateX(0); }
        }

        #stats-container {
            position:absolute;
            bottom:10px;
            left:10px;
            font-size:14px;
            color:#fff;
            background: rgba(0,0,0,0.5);
            padding:6px 10px;
            border-radius:5px;
            border:1px solid #ff003c;
            z-index:11;
            pointer-events:none;
            animation: statsFloat 3s infinite ease-in-out;
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.5);
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        @keyframes statsFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        #weapon-display {
            position:absolute;
            bottom:10px;
            right:10px;
            font-size:16px;
            color:#fff;
            background: rgba(0,0,0,0.5);
            padding:6px 10px;
            border-radius:5px;
            border:1px solid #ff003c;
            z-index:11;
            pointer-events:none;
            animation: weaponPulse 2s infinite alternate;
            box-shadow: 0 0 10px rgba(255, 0, 60, 0.5);
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        @keyframes weaponPulse {
            from { box-shadow: 0 0 5px #ff003c; }
            to { box-shadow: 0 0 15px #ff003c, 0 0 20px rgba(255, 0, 60, 0.5); }
        }

        #abilities-display { 
            position:absolute; 
            bottom:50px; 
            left:10px; 
            display:flex; 
            gap:10px; 
            z-index:11; 
            pointer-events:none; 
        }
        
        .ability { 
            width:44px; 
            height:44px; 
            background:rgba(0,0,0,0.5); 
            border:1px solid #ff003c; 
            border-radius:5px; 
            display:flex; 
            align-items:center; 
            justify-content:center; 
            color:#fff; 
            font-size:12px; 
            pointer-events:none; 
            text-align:center; 
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(255, 0, 60, 0.5);
            position: relative;
            overflow: hidden;
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        .ability::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }
        
        .ability.ready::before {
            left: 100%;
        }

        .ability.cooldown { 
            opacity:0.4; 
            filter: grayscale(1);
        }

        /* Blood overlay */
        #blood-overlay { 
            position:absolute; 
            top:0; 
            left:0; 
            width:100%; 
            height:100%; 
            pointer-events:none; 
            opacity:0; 
            z-index:5; 
            background: radial-gradient(circle, rgba(255,0,0,0.3) 0%, transparent 70%);
            transition: opacity 0.3s ease;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #ffcc00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 12;
            box-shadow: 0 0 5px #ffcc00;
            animation: crosshairPulse 1s infinite alternate;
        }

        @keyframes crosshairPulse {
            from { transform: scale(1); opacity: 0.8; }
            to { transform: scale(1.2); opacity: 1; }
        }

        /* Game over screen */
        #game-over {
            position:absolute;
            top:0;
            left:0;
            width:100%;
            height:100%;
            background: rgba(0,0,0,0.8);
            display:none;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            z-index:20;
            animation: fadeIn 0.5s ease;
        }

        /* Guidebook */
        #guidebook {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 950;
            color: #fff;
            padding: 20px;
            text-align: center;
        }

        .guidebook-content {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #ff003c;
            border-radius: 10px;
            padding: 30px;
            max-width: 800px;
            max-height: 80%;
            overflow-y: auto;
        }

        .guidebook-content h2 {
            color: #ff003c;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
            font-style: italic;
        }

        .guidebook-content p {
            margin-bottom: 15px;
            font-size: 20px;
            text-shadow: 1px 1px 0 #000;
            font-style: italic;
        }

        /* Multiplayer Lobby */
        #multiplayer-lobby {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 950;
            color: #fff;
            padding: 20px;
        }

        .lobby-content {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #ff003c;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        .lobby-content h2 {
            color: #ff003c;
            font-size: 36px;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 0 #000;
            font-style: italic;
        }

        .player-list {
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ff003c;
            padding: 10px;
            border-radius: 5px;
        }

        .player-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 0, 60, 0.1);
            border: 1px solid #ff003c;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
        }

        .player-name {
            font-weight: bold;
        }

        .player-ready {
            color: #00ff00;
        }

        .lobby-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        /* Custom cursor for main menu */
        body.menu-mode {
            cursor: auto;
        }

        .custom-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #ff003c;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #ff003c;
            display: none;
        }

        .cursor-dot {
            position: fixed;
            width: 4px;
            height: 4px;
            background-color: #ff003c;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            display: none;
        }
        
        .game-code-display {
            text-align: center;
            margin: 15px 0;
            font-size: 24px;
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
        }

        /* Stage Transition */
        #stage-transition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 25;
            color: #fff;
        }
        
        /* Modifiers panel */
        #modifiers-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 960;
            color: #fff;
        }

        .modifiers-content {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #ff003c;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        .modifiers-content h2 {
            color: #ff003c;
            font-size: 36px;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 0 #000;
            font-style: italic;
        }

        .modifier-option {
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 0, 60, 0.1);
            border: 2px solid #ff003c;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modifier-option:hover {
            background: rgba(255, 0, 60, 0.3);
            transform: scale(1.05);
        }

        .modifier-option.selected {
            background: rgba(255, 0, 60, 0.5);
            box-shadow: 0 0 15px #ff003c;
        }

        .modifier-title {
            font-size: 20px;
            color: #ffcc00;
            margin-bottom: 5px;
            text-shadow: 1px 1px 0 #000;
        }

        .modifier-desc {
            font-size: 16px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        .modifiers-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .stage-text {
            font-size: 48px;
            color: #ff003c;
            text-shadow: 0 0 20px #ff003c;
            margin-bottom: 20px;
            animation: stagePulse 2s infinite;
        }

        @keyframes stagePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .substage-options {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .substage-option {
            padding: 15px 25px;
            background: rgba(255, 0, 60, 0.2);
            border: 2px solid #ff003c;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            width: 200px;
        }

        .substage-option:hover {
            background: rgba(255, 0, 60, 0.4);
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff003c;
        }

        .substage-title {
            font-size: 20px;
            color: #ffcc00;
            margin-bottom: 10px;
            text-shadow: 1px 1px 0 #000;
        }

        .substage-desc {
            font-size: 14px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        /* Effects */
        .screen-shake {
            animation: screenShake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes screenShake {
            10%, 90% { transform: translate(-1px, 0); }
            20%, 80% { transform: translate(2px, 0); }
            30%, 50%, 70% { transform: translate(-4px, 0); }
            40%, 60% { transform: translate(4px, 0); }
        }

        /* Shield Effect */
        .shield-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0, 204, 255, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        /* Zoom transition */
        .zoom-transition {
            animation: zoomOut 1s ease-out forwards;
        }

        @keyframes zoomOut {
            from { transform: scale(1); }
            to { transform: scale(0.8); }
        }
        
        /* Multiplayer Player List */
        #multiplayer-player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff003c;
            border-radius: 5px;
            padding: 10px;
            z-index: 15;
            max-width: 250px;
            width: 100%;
            display: none;
        }

        .player-list-title {
            color: #ff003c;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 1px 1px 0 #000;
            border-bottom: 1px solid #ff003c;
            padding-bottom: 5px;
        }

        .multiplayer-player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 5px 0;
            background: rgba(255, 0, 60, 0.1);
            border: 1px solid #ff003c;
            border-radius: 3px;
        }

        .player-info {
            display: flex;
            align-items: center;
        }

        .player-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .player-status.alive {
            background-color: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        .player-status.dead {
            background-color: #ff003c;
            box-shadow: 0 0 5px #ff003c;
        }

        .player-stats {
            font-size: 12px;
            color: #cccccc;
            text-shadow: 1px 1px 0 #000;
        }

        /* Connection status */
        #connection-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff003c;
            border-radius: 5px;
            padding: 8px 12px;
            color: #fff;
            font-size: 14px;
            z-index: 15;
            display: none;
        }

        .status-connected {
            color: #00ff00;
        }

        .status-disconnected {
            color: #ff003c;
        }

        /* Player name input */
        .name-input-container {
            margin-bottom: 20px;
            width: 100%;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff003c;
            border-radius: 5px;
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 18px;
            text-align: center;
        }

        .name-input:focus {
            outline: none;
            box-shadow: 0 0 10px #ff003c;
        }

        /* Error message */
        .error-message {
            color: #ff003c;
            margin-top: 10px;
            text-align: center;
            font-size: 16px;
            text-shadow: 1px 1px 0 #000;
        }
    </style>
</head>
<body class="crt">
    <div class="custom-cursor"></div>
    <div class="cursor-dot"></div>

    <div id="loading-screen">
        <div class="loading-text">LOADING RETROKILL: REMASTERED</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <div id="main-menu">
        <div class="menu-background">
            <canvas id="menu-canvas"></canvas>
        </div>
        <div class="menu-content">
            <div class="title">RETROKILL</div>
            
            <div class="name-input-container">
                <input type="text" class="name-input" id="player-name-input" placeholder="ENTER YOUR NAME" maxlength="15" value="Player">
            </div>
            
            <div class="menu-options">
                <div class="menu-option" id="singleplayer-button">SINGLEPLAYER</div>
                <div class="menu-option" id="host-button">HOST GAME</div>
                <div class="menu-option" id="join-button">JOIN GAME</div>
                <div class="menu-option" id="modifiers-button">MODIFIERS</div>
                <div class="menu-option" id="tutorial-button">TUTORIAL</div>
                <div class="menu-option" id="settings-button">SETTINGS</div>
                <div class="menu-option" id="quit-button">QUIT GAME</div>
            </div>

            <div class="settings-panel" id="settings-panel">
                <div class="setting-item">
                    <label class="setting-label">Graphics Quality</label>
                    <input type="range" min="0" max="2" value="2" class="slider" id="graphics-quality">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Master Volume</label>
                    <input type="range" min="0" max="100" value="80" class="slider" id="master-volume">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Effects Volume</label>
                    <input type="range" min="0" max="100" value="100" class="slider" id="effects-volume">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Music Volume</label>
                    <input type="range" min="0" max="100" value="70" class="slider" id="music-volume">
                </div>
            </div>
        </div>
    </div>

    <div id="modifiers-panel">
        <div class="modifiers-content">
            <h2>SELECT MODIFIERS</h2>
            <div class="modifier-option" data-modifier="double-health">
                <div class="modifier-title">DOUBLE HEALTH</div>
                <div class="modifier-desc">Player health is doubled</div>
            </div>
            <div class="modifier-option" data-modifier="mach-speed">
                <div class="modifier-title">MACH SPEED</div>
                <div class="modifier-desc">Player movement speed increased by 50%</div>
            </div>
            <div class="modifier-option" data-modifier="random-buff">
                <div class="modifier-title">RANDOM BUFF</div>
                <div class="modifier-desc">Get a random buff at the start of each stage</div>
            </div>
            <div class="modifier-option" data-modifier="hard-mode">
                <div class="modifier-title">HARD MODE</div>
                <div class="modifier-desc">Enemies deal double damage</div>
            </div>
            <div class="modifier-option" data-modifier="infinite-mode">
                <div class="modifier-title">INFINITE MODE</div>
                <div class="modifier-desc">Stages continue infinitely with increasing difficulty</div>
            </div>
            <div class="modifiers-actions">
                <div class="menu-option" id="modifiers-back">BACK</div>
                <div class="menu-option" id="modifiers-confirm">CONFIRM</div>
            </div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>

        <div id="effects-container">
            <div class="chromatic-aberration" id="chromatic-aberration"></div>
            <div class="pixelation" id="pixelation"></div>
            <div class="shield-effect" id="shield-effect"></div>
        </div>

        <div id="blood-overlay"></div>
        <div id="crosshair"></div>

        <div id="connection-status">
            Connection: <span class="status-connected" id="connection-text">Connected</span>
        </div>

        <div id="ui-container">
            <div class="health-bar">
                <div id="shield-bar"></div>
                <div id="health-fill"></div>
            </div>
            <div id="style-container">
                <div id="style-meter">DESTRUCTIVE</div>
                <div id="style-bar"><div id="style-fill"></div></div>
            </div>
            <div id="score">SCORE: 0</div>
        </div>

        <div id="stats-container">
            <div>KILLS: <span id="kill-count">0</span></div>
            <div>COMBO: <span id="combo-count">0</span>x</div>
            <div>ACCURACY: <span id="accuracy">100%</span></div>
            <div>STAGE: <span id="stage-display">1-0</span></div>
        </div>

        <div id="weapon-display">REVOLVER [1]</div>

        <div id="abilities-display">
            <div class="ability" id="dash-ability">DASH<br>[SHIFT]</div>
            <div class="ability" id="parry-ability">PARRY<br>[E]</div>
            <div class="ability" id="grenade-ability">GRENADE<br>[Q]</div>
            <div class="ability" id="convert-ability">CONVERT<br>[F]</div>
        </div>

        <div id="multiplayer-player-list">
            <div class="player-list-title">PLAYERS</div>
            <div id="players-container"></div>
        </div>

        <div id="game-over">
            <h2 style="color:#ff003c; font-size: 36px; text-shadow: 2px 2px 0 #000;">YOU DIED</h2>
            <div id="final-score" style="color:#fff; margin-top:20px; font-size: 24px; text-shadow: 1px 1px 0 #000;">SCORE: 0</div>
            <div id="final-stats" style="color:#fff; margin-top:10px; text-shadow: 1px 1px 0 #000;">
                <div>KILLS: <span id="final-kills">0</span></div>
                <div>MAX COMBO: <span id="final-combo">0</span>x</div>
                <div>ACCURACY: <span id="final-accuracy">100%</span></div>
                <div>STAGE REACHED: <span id="final-stage">1-0</span></div>
            </div>
            <div class="menu-option" id="restart-button" style="margin-top: 20px;">RETRY</div>
            <div class="menu-option" id="menu-button" style="margin-top: 10px;">MAIN MENU</div>
        </div>

        <div id="stage-transition">
            <div class="stage-text" id="stage-text">STAGE 1 - SUBSTAGE 1</div>
            <div class="substage-options" id="substage-options">
                <div class="substage-option" data-substage="1">
                    <div class="substage-title">ASSAULT</div>
                    <div class="substage-desc">• Double style points<br>• Health regeneration<br>• Rapid shotgun<br>• Automatic obstacles</div>
                </div>
                <div class="substage-option" data-substage="2">
                    <div class="substage-title">DOMINATION</div>
                    <div class="substage-desc">• Convert enemies to allies<br>• Defensive buffs<br>• Shield enhancement<br>• Hazardous obstacles</div>
                </div>
            </div>
        </div>
    </div>

    <div id="multiplayer-lobby">
        <div class="lobby-content">
            <h2>MULTIPLAYER LOBBY</h2>
            <div class="game-code-display" id="game-code">CODE: 0000</div>
            <div class="player-list" id="lobby-player-list">
                <!-- Player list will be populated here -->
            </div>
            <div class="ready-button-container">
                <div class="menu-option" id="ready-button">READY</div>
            </div>
            <div class="lobby-actions">
                <div class="menu-option" id="lobby-back">BACK</div>
                <div class="menu-option" id="start-game">START GAME</div>
            </div>
        </div>
    </div>

    <div id="guidebook">
        <div class="guidebook-content">
            <h2>RETROKILL GUIDEBOOK</h2>
            <p>CONTROLS:</p>
            <p>WASD - Move</p>
            <p>Mouse - Aim</p>
            <p>Left Click - Shoot</p>
            <p>Shift - Dash</p>
            <p>E - Parry</p>
            <p>Q - Throw Grenade</p>
            <p>F - Convert Enemy (Substage 2)</p>
            <p>1-4 - Switch Weapons</p>
            <br>
            <p>TIPS:</p>
            <p>- Parry just before being hit to create an explosion</p>
            <p>- Collect red orbs to heal</p>
            <p>- Higher style levels give more points</p>
            <p>- Killing enemies gives you shield health</p>
            <p>- Excess health becomes blue shield with benefits</p>
            <p>- Choose substages to gain powerful abilities</p>
            <br>
            <div class="menu-option" id="back-button">BACK</div>
        </div>
    </div>

    <script>
        window.multiplayerPlayerObjects = {};
    // Firebase configuration - Replace with your own Firebase project config
    const firebaseConfig = {
        apiKey: "AIzaSyAer8Y2j4cGrEkqpRKCmd3H3b3vZNXtTBw",
        authDomain: "retrokill-73ce9.firebaseapp.com",
        projectId: "retrokill-73ce9",
        storageBucket: "retrokill-73ce9.firebasestorage.app",
        messagingSenderId: "787661292350",
        appId: "1:787661292350:web:0ddfa5d7ad315476dda26f",
        measurementId: "G-BLTZCY62PX"
    };
    
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    
    // Multiplayer state
    let currentGameId = null;
    let playerId = null;
    let isHost = false;
    let multiplayerMode = false;
    let playerName = "Player";
    
    // Multiplayer manager class
    class MultiplayerManager {
        constructor() {
            this.gameUnsubscribe = null;
            this.playersUnsubscribe = null;
            this.connectionStatus = 'disconnected';
            this.gameState = {
                enemies: [],
                bloodDrops: [],
                bullets: [],
                grenades: [],
                particles: [],
                explosions: [],
                obstacles: [],
                stage: 1,
                substage: 0,
                difficulty: 1,
                score: 0,
                kills: 0
            };
        }
        async updatePlayerAction(action, data = {}) {
    if (!currentGameId || !playerId) return;
    this.lastActionTimestamps = {};

    try {
        await db.collection('games').doc(currentGameId).update({
            [`players.${playerId}.action`]: {
                type: action,
                ...data,
                timestamp: Date.now()
            }
        });
    } catch (error) {
        console.error("Error updating player action:", error);
    }
}
        
        // Create a new game session
        async createGame(playerName) {
            try {
                // Generate a unique game ID
                const gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
                
                // Create player data
                playerId = Math.random().toString(36).substring(2, 10);
                const playerData = {
                    id: playerId,
                    name: playerName,
                    x: 400,
                    y: 300,
                    health: 100,
                    maxHealth: 100,
                    score: 0,
                    kills: 0,
                    alive: true,
                    ready: false,
                    joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Create game document
                await db.collection('games').doc(gameId).set({
                    id: gameId,
                    status: 'lobby',
                    hostId: playerId,
                    players: {
                        [playerId]: playerData
                    },
                    gameState: this.gameState,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                currentGameId = gameId;
                isHost = true;
                multiplayerPlayers[playerId] = playerData;
                this.connectionStatus = 'connected';
                updateConnectionStatus();
                
                // Set up real-time listener for this game
                this.setupGameListener(gameId);
                
                return gameId;
            } catch (error) {
                console.error("Error creating game:", error);
                showError("Failed to create game. Please check your Firebase configuration.");
                return null;
            }
        }
        
        // Join an existing game
        async joinGame(gameId, playerName) {
            try {
                // Check if game exists
                const gameDoc = await db.collection('games').doc(gameId).get();
                if (!gameDoc.exists) {
                    showError("Game not found. Please check the code and try again.");
                    return false;
                }
                
                const gameData = gameDoc.data();
                if (gameData.status !== 'lobby') {
                    showError("This game is already in progress.");
                    return false;
                }
                
                // Create player data
                playerId = Math.random().toString(36).substring(2, 10);
                const playerData = {
                    id: playerId,
                    name: playerName,
                    x: 400,
                    y: 300,
                    health: 100,
                    maxHealth: 100,
                    score: 0,
                    kills: 0,
                    alive: true,
                    ready: false,
                    joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Add player to game
                await db.collection('games').doc(gameId).update({
                    [`players.${playerId}`]: playerData
                });
                
                currentGameId = gameId;
                isHost = false;
                multiplayerPlayers[playerId] = playerData;
                this.connectionStatus = 'connected';
                updateConnectionStatus();
                
                // Set up real-time listener for this game
                this.setupGameListener(gameId);
                
                return true;
            } catch (error) {
                console.error("Error joining game:", error);
                showError("Failed to join game. Please check your Firebase configuration.");
                return false;
            }
        }
        
        // Set up real-time listener for game changes
        setupGameListener(gameId) {
            // Unsubscribe from any previous listener
            if (this.gameUnsubscribe) {
                this.gameUnsubscribe();
            }
            
            this.gameUnsubscribe = db.collection('games').doc(gameId)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const gameData = doc.data();
                        this.handleGameUpdate(gameData);
                    }
                }, (error) => {
                    console.error("Game listener error:", error);
                    this.connectionStatus = 'disconnected';
                    updateConnectionStatus();
                });
        }
        
        // Handle game data updates
        handleGameUpdate(gameData) {
    // Update players list
    if (gameData.players) {
        multiplayerPlayers = gameData.players;
        this.updateLobbyPlayersUI();
        this.updatePlayersUI();
        
        // Update multiplayer player objects for rendering
        for (const playerId in gameData.players) {
            if (playerId !== playerId) { // Skip local player
                const playerData = gameData.players[playerId];
                if (!window.multiplayerPlayerObjects[playerId]) {
                    window.multiplayerPlayerObjects[playerId] = new MultiplayerPlayer(
                        playerId, 
                        playerData.name, 
                        playerData.x, 
                        playerData.y
                    );
                } else {
                    window.multiplayerPlayerObjects[playerId].update(playerData);
                }
            }
        }
        
        // Remove players that left
        for (const playerId in window.multiplayerPlayerObjects) {
            if (!gameData.players[playerId]) {
                delete window.multiplayerPlayerObjects[playerId];
            }
        }
    }
               // Handle player actions
    if (gameData.players) {
        for (const playerId in gameData.players) {
            const player = gameData.players[playerId];
            if (player.action && player.action.timestamp > (this.lastActionTimestamps[playerId] || 0)) {
                this.lastActionTimestamps[playerId] = player.action.timestamp;
                
                if (playerId !== playerId && window.multiplayerPlayerObjects[playerId]) {
                    window.multiplayerPlayerObjects[playerId].showAction(player.action.type);
                }
            }
        }
    }
            // Update game state if in multiplayer mode
            if (multiplayerMode && gameData.gameState) {
                this.gameState = gameData.gameState;
                
                // Sync game state if not the host
                if (!isHost) {
                    enemies = this.gameState.enemies;
                    bloodDrops = this.gameState.bloodDrops;
                    bullets = this.gameState.bullets;
                    grenades = this.gameState.grenades;
                    particles = this.gameState.particles;
                    explosions = this.gameState.explosions;
                    obstacles = this.gameState.obstacles;
                    stage = this.gameState.stage;
                    substage = this.gameState.substage;
                    difficulty = this.gameState.difficulty;
                    score = this.gameState.score;
                    kills = this.gameState.kills;
                    
                    // Update UI
                    scoreDisplay.textContent = `SCORE: ${score}`;
                    killCount.textContent = kills;
                    stageDisplay.textContent = `${stage}-${substage}`;
                }
            }
        }
        
        // Update player status in the game
        async updatePlayerStatus(data) {
            if (!currentGameId || !playerId) return;
            
            try {
                await db.collection('games').doc(currentGameId).update({
                    [`players.${playerId}`]: {
                        ...multiplayerPlayers[playerId],
                        ...data
                    }
                });
            } catch (error) {
                console.error("Error updating player status:", error);
            }
        }
        
        // Update game state (host only)
        async updateGameState() {
            if (!currentGameId || !isHost) return;
            
            try {
                this.gameState = {
                    enemies: enemies,
                    bloodDrops: bloodDrops,
                    bullets: bullets,
                    grenades: grenades,
                    particles: particles,
                    explosions: explosions,
                    obstacles: obstacles,
                    stage: stage,
                    substage: substage,
                    difficulty: difficulty,
                    score: score,
                    kills: kills
                };
                
                await db.collection('games').doc(currentGameId).update({
                    gameState: this.gameState
                });
            } catch (error) {
                console.error("Error updating game state:", error);
            }
        }
        
        // Update the players UI list
        updatePlayersUI() {
            const playersContainer = document.getElementById('players-container');
            playersContainer.innerHTML = '';
            
            Object.values(multiplayerPlayers).forEach(player => {
                const playerElement = document.createElement('div');
                playerElement.className = 'multiplayer-player-item';
                
                playerElement.innerHTML = `
                    <div class="player-info">
                        <div class="player-status ${player.alive ? 'alive' : 'dead'}"></div>
                        <div class="player-name">${player.name || 'Unknown'}</div>
                    </div>
                    <div class="player-stats">
                        K:${player.kills || 0} S:${player.score || 0} H:${player.health || 0}
                    </div>
                `;
                
                playersContainer.appendChild(playerElement);
            });
            
            // Show the player list in multiplayer mode
            if (multiplayerMode) {
                document.getElementById('multiplayer-player-list').style.display = 'block';
            }
        }
        
        // Update the lobby players UI list
        updateLobbyPlayersUI() {
            const lobbyPlayerList = document.getElementById('lobby-player-list');
            lobbyPlayerList.innerHTML = '';
            
            Object.values(multiplayerPlayers).forEach(player => {
                const playerElement = document.createElement('div');
                playerElement.className = 'player-item';
                
                playerElement.innerHTML = `
                    <span class="player-name">${player.name || 'Unknown'} ${player.id === this.getHostId() ? '(Host)' : ''}</span>
                    <span class="player-ready">${player.ready ? 'READY' : 'NOT READY'}</span>
                `;
                
                lobbyPlayerList.appendChild(playerElement);
            });
        }
        
        // Get host ID
        getHostId() {
            if (!currentGameId) return null;
            for (const playerId in multiplayerPlayers) {
                if (multiplayerPlayers[playerId].isHost) {
                    return playerId;
                }
            }
            return null;
        }
        
        // Set player ready status
        async setReadyStatus(ready) {
            if (!currentGameId || !playerId) return;
            
            try {
                await db.collection('games').doc(currentGameId).update({
                    [`players.${playerId}.ready`]: ready
                });
            } catch (error) {
                console.error("Error updating ready status:", error);
            }
        }
        
        // Start the game (host only)
        async startGame() {
            if (!currentGameId || !isHost) return;
            
            try {
                // Check if all players are ready
                const allReady = Object.values(multiplayerPlayers).every(player => player.ready);
                
                if (!allReady) {
                    showError("Not all players are ready!");
                    return;
                }
                
                await db.collection('games').doc(currentGameId).update({
                    status: 'playing',
                    startedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            } catch (error) {
                console.error("Error starting game:", error);
            }
        }
        
        // Leave the current game
        async leaveGame() {
            if (!currentGameId || !playerId) return;
            
            try {
                // Remove player from game
                await db.collection('games').doc(currentGameId).update({
                    [`players.${playerId}`]: firebase.firestore.FieldValue.delete()
                });
                
                // If host and no players left, delete the game
                if (isHost) {
                    const gameDoc = await db.collection('games').doc(currentGameId).get();
                    if (gameDoc.exists) {
                        const gameData = gameDoc.data();
                        if (!gameData.players || Object.keys(gameData.players).length === 0) {
                            await db.collection('games').doc(currentGameId).delete();
                        }
                    }
                }
            } catch (error) {
                console.error("Error leaving game:", error);
            }
            
            // Reset multiplayer state
            if (this.gameUnsubscribe) {
                this.gameUnsubscribe();
            }
            if (this.playersUnsubscribe) {
                this.playersUnsubscribe();
            }
            
            currentGameId = null;
            playerId = null;
            isHost = false;
            multiplayerPlayers = {};
            multiplayerMode = false;
            this.connectionStatus = 'disconnected';
            updateConnectionStatus();
            
            // Hide player list
            document.getElementById('multiplayer-player-list').style.display = 'none';
        }
    }
    
    // Create multiplayer manager instance
    const multiplayerManager = new MultiplayerManager();
    let multiplayerPlayers = {};
    // DOM references
    const gameContainer = document.getElementById('game-container');
    const canvas = document.getElementById('game-canvas');
    const menuCanvas = document.getElementById('menu-canvas');
    const ctx = canvas.getContext('2d');
    const menuCtx = menuCanvas.getContext('2d');
    const loadingScreen = document.getElementById('loading-screen');
    const progressFill = document.getElementById('progress-fill');
    const mainMenu = document.getElementById('main-menu');
    const settingsPanel = document.getElementById('settings-panel');
    const singleplayerButton = document.getElementById('singleplayer-button');
    const hostButton = document.getElementById('host-button');
    const joinButton = document.getElementById('join-button');
    const modifiersButton = document.getElementById('modifiers-button');
    const tutorialButton = document.getElementById('tutorial-button');
    const settingsButton = document.getElementById('settings-button');
    const quitButton = document.getElementById('quit-button');
    const restartButton = document.getElementById('restart-button');
    const menuButton = document.getElementById('menu-button');
    const gameOverScreen = document.getElementById('game-over');
    const guidebook = document.getElementById('guidebook');
    const backButton = document.getElementById('back-button');
    const healthFill = document.getElementById('health-fill');
    const shieldBar = document.getElementById('shield-bar');
    const styleMeter = document.getElementById('style-meter');
    const styleFill = document.getElementById('style-fill');
    const scoreDisplay = document.getElementById('score');
    const finalScoreDisplay = document.getElementById('final-score');
    const bloodOverlay = document.getElementById('blood-overlay');
    const weaponDisplay = document.getElementById('weapon-display');
    const killCount = document.getElementById('kill-count');
    const comboCount = document.getElementById('combo-count');
    const accuracyDisplay = document.getElementById('accuracy');
    const stageDisplay = document.getElementById('stage-display');
    const finalKills = document.getElementById('final-kills');
    const finalCombo = document.getElementById('final-combo');
    finalAccuracy = document.getElementById('final-accuracy');
    const finalStage = document.getElementById('final-stage');
    const dashAbility = document.getElementById('dash-ability');
    const parryAbility = document.getElementById('parry-ability');
    const grenadeAbility = document.getElementById('grenade-ability');
    const convertAbility = document.getElementById('convert-ability');
    const crosshair = document.getElementById('crosshair');
    const chromaticAberration = document.getElementById('chromatic-aberration');
    const shieldEffect = document.getElementById('shield-effect');
    const multiplayerLobby = document.getElementById('multiplayer-lobby');
    const gameCodeDisplay = document.getElementById('game-code');
    const lobbyBackButton = document.getElementById('lobby-back');
    const startGameButton = document.getElementById('start-game');
    const readyButton = document.getElementById('ready-button');
    const stageTransition = document.getElementById('stage-transition');
    const stageText = document.getElementById('stage-text');
    const substageOptions = document.getElementById('substage-options');
    const modifiersPanel = document.getElementById('modifiers-panel');
    const modifiersBackButton = document.getElementById('modifiers-back');
    const modifiersConfirmButton = document.getElementById('modifiers-confirm');
    const customCursor = document.querySelector('.custom-cursor');
    const cursorDot = document.querySelector('.cursor-dot');
    const playerNameInput = document.getElementById('player-name-input');
    const connectionStatus = document.getElementById('connection-status');
    const connectionText = document.getElementById('connection-text');

    // Game state
    let gameActive = false;
    let player = null;
    let enemies = [];
    let allies = [];
    let bloodDrops = [];
    let bullets = [];
    let grenades = [];
    let particles = [];
    let explosions = [];
    let obstacles = [];
    let score = 0;
    let styleLevel = 0;
    let stylePoints = 0;
    let styleTimeout = null;
    let lastTime = 0;
    let keys = {};
    let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
    let cameraShake = 0;
    let cameraOffset = { x: 0, y: 0 };
    let cameraZoom = 1.0;
    let shotsFired = 0;
    let shotsHit = 0;
    let kills = 0;
    let combo = 0;
    let comboTimeout = null;
    let maxCombo = 0;
    let difficulty = 1;
    let dashCooldown = 0;
    let parryCooldown = 0;
    let grenadeCooldown = 0;
    let convertCooldown = 0;
    let parryActive = false;
    let parryTime = 0;
    let bloodIntensity = 0;
    let playAreaSize = 1.0;
    let stage = 1;
    let substage = 0;
    let enemySpawnTimer = 0;
    let graphicsQuality = 2;
    let masterVolume = 0.8;
    let effectsVolume = 1.0;
    let musicVolume = 0.7;
    let zoomLevel = 1.0;
    let aimAssistTarget = null;
    let aimAssistStrength = 0;
    let healthRegenTimer = 0;
    let shieldDamageReduction = 0.5;
    let shieldCooldownBonus = 0.2;
    let stageTransitionActive = false;
    let selectedModifiers = [];
    let currentBuff = null;
    let buffTimer = 0;
    let infiniteMode = false;
    let playerReady = false;
    let gameStateUpdateInterval = null;

    // Weapons
    const weapons = [
        { name: "REVOLVER", key: "1", damage: 1, cooldown: 0.2, speed: 12, color: "#ffcc00", precision: 0.95 },
        { name: "SHOTGUN", key: "2", damage: 3, cooldown: 0.8, speed: 8, color: "#ff3300", precision: 0.7, pellets: 5 },
        { name: "AUTO SHOTGUN", key: "2", damage: 1.8, cooldown: 0.4, speed: 8, color: "#ff6600", precision: 0.6, pellets: 5 },
        { name: "NAILGUN", key: "3", damage: 0.5, cooldown: 0.1, speed: 10, color: "#00ccff", precision: 0.85 },
        { name: "RAILGUN", key: "4", damage: 10, cooldown: 1.5, speed: 20, color: "#ff00ff", precision: 1.0, pierce: true }
    ];
    let currentWeapon = 0;

    // Style ranks & thresholds
    const styleRankings = ["DESTRUCTIVE","DISASTROUS","DEVASTATING","DISGUSTING","BLOODBATH","RETROKILL"];
    const styleThresholds = [0,5,15,30,50,75];

    // Enemy types by stage
    const enemyTypesByStage = {
        1: ['FILTH'],
        2: ['FILTH', 'SCHISM'],
        3: ['FILTH', 'SCHISM', 'IDOL'],
        4: ['FILTH', 'SCHISM', 'IDOL', 'TITAN'],
        5: ['FILTH', 'SCHISM', 'IDOL', 'TITAN', 'NIGHTMARE']
    };

    // Enemy health values for shield calculation
    const enemyHealthValues = {
        'FILTH': 3,
        'SCHISM': 8,
        'IDOL': 5,
        'TITAN': 20,
        'NIGHTMARE': 15
    };

    // Buff types
    const buffTypes = [
        {
            name: "SPEED BOOST",
            color: "#00ff00",
            effect: (player) => { player.speed *= 1.5; },
            revert: (player) => { player.speed /= 1.5; },
            duration: 10
        },
        {
            name: "DAMAGE BOOST",
            color: "#ff0000",
            effect: (player) => { /* Handled in damage calculation */ },
            revert: (player) => { /* Handled in damage calculation */ },
            duration: 10
        },
        {
            name: "RAPID FIRE",
            color: "#00ffff",
            effect: (player) => { weapons.forEach(w => w.cooldown *= 0.5); },
            revert: (player) => { weapons.forEach(w => w.cooldown /= 0.5); },
            duration: 8
        },
        {
            name: "INVULNERABILITY",
            color: "#ffff00",
            effect: (player) => { player.invulnerable = true; },
            revert: (player) => { player.invulnerable = false; },
            duration: 5
        }
    ];

    // Utility functions
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const distance = (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

    // Helper functions for UI
    function updateConnectionStatus() {
        if (multiplayerMode) {
            connectionStatus.style.display = 'block';
            if (multiplayerManager.connectionStatus === 'connected') {
                connectionText.textContent = 'Connected';
                connectionText.className = 'status-connected';
            } else {
                connectionText.textContent = 'Disconnected';
                connectionText.className = 'status-disconnected';
            }
        } else {
            connectionStatus.style.display = 'none';
        }
    }

    function showError(message) {
        // Create error message element
        const errorElement = document.createElement('div');
        errorElement.className = 'error-message';
        errorElement.textContent = message;
        
        // Add to the main menu
        const menuContent = document.querySelector('.menu-content');
        menuContent.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (menuContent.contains(errorElement)) {
                menuContent.removeChild(errorElement);
            }
        }, 3000);
    }

    // Player class
    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 20;
            this.speed = 5;
            this.health = 100;
            this.maxHealth = 100;
            this.shieldHealth = 0;
            this.maxShieldHealth = 200;
            this.color = '#ff003c';
            this.shootCooldown = 0;
            this.rotation = 0;
            this.dashPower = 15;
            this.dashTime = 0;
            this.dashDuration = 0.2;
            this.dashing = false;
            this.parryDuration = 0.3;
            this.trail = [];
            this.trailLength = 10;
            this.invulnerable = false;
            this.healthRegen = 0; // Health regeneration per second (percentage)
            this.lastUpdate = Date.now();
            // Apply modifiers
            if (selectedModifiers.includes('double-health')) {
                this.health = 200;
                this.maxHealth = 200;
            }
            if (selectedModifiers.includes('mach-speed')) {
                this.speed *= 1.5;
            }
        }

        update(deltaTime) {
            // Health regeneration (if enabled by substage)
            if (this.healthRegen > 0 && this.health < this.maxHealth) {
                healthRegenTimer += deltaTime;
                if (healthRegenTimer >= 1) {
                    this.heal(this.maxHealth * this.healthRegen);
                    healthRegenTimer = 0;
                }
            }

            // Dashing countdown
            if (this.dashing) {
                this.dashTime -= deltaTime;
                if (this.dashTime <= 0) this.dashing = false;
            }

            // Movement input
            let moveX = 0, moveY = 0;
            if (keys['KeyW']) moveY -= 1;
            if (keys['KeyS']) moveY += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            if (moveX !== 0 || moveY !== 0) {
                const len = Math.hypot(moveX, moveY) || 1;
                moveX /= len; moveY /= len;
            }

            const moveSpeed = this.dashing ? this.speed * 3 : this.speed;
            this.x += moveX * moveSpeed;
            this.y += moveY * moveSpeed;

            // Add trail point
            this.trail.push({x: this.x, y: this.y, life: 1});
            if (this.trail.length > this.trailLength) this.trail.shift();

            // Aim assist interpolation
            let targetAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
            if (aimAssistTarget) {
                const dx = aimAssistTarget.x - this.x;
                const dy = aimAssistTarget.y - this.y;
                const targetAssistAngle = Math.atan2(dy, dx);
                targetAngle = lerp(targetAngle, targetAssistAngle, aimAssistStrength);
                aimAssistStrength = Math.max(0, aimAssistStrength - deltaTime * 2);
            }
            
            // Smooth rotation
            this.rotation = lerp(this.rotation, targetAngle, 0.2);

            // Keep inside bounds (scaled by playAreaSize)
            const bounds = getPlayAreaBounds();
            this.x = clamp(this.x, bounds.minX + this.radius, bounds.maxX - this.radius);
            this.y = clamp(this.y, bounds.minY + this.radius, bounds.maxY - this.radius);

            // Shooting cooldown (with shield cooldown bonus)
            const cooldownModifier = this.shieldHealth > 0 ? (1 - shieldCooldownBonus) : 1;
            if (this.shootCooldown > 0) this.shootCooldown -= deltaTime * cooldownModifier;

            // Parry handling
            if (parryActive) {
                parryTime -= deltaTime;
                if (parryTime <= 0) parryActive = false;
            }

            // Update trail
            for (let i = 0; i < this.trail.length; i++) {
                this.trail[i].life -= 0.05;
            }
            this.trail = this.trail.filter(point => point.life > 0);
            
       
    // Update multiplayer status more frequently
    if (multiplayerMode && playerId && Date.now() - this.lastUpdate > 100) {
        multiplayerManager.updatePlayerStatus({
            x: this.x,
            y: this.y,
            health: this.health,
            rotation: this.rotation,
            score: score,
            kills: kills,
            alive: this.health > 0
        });
        this.lastUpdate = Date.now();
    }
}

        draw() {
            // camera shake offsets
            const shakeX = cameraShake > 0 ? (Math.random() - 0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random() - 0.5) * cameraShake : 0;

            // Draw trail
            for (let i = 0; i < this.trail.length; i++) {
                const point = this.trail[i];
                const alpha = point.life * 0.3;
                const size = this.radius * (i / this.trail.length) * 0.8;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(point.x + shakeX, point.y + shakeY, size, 0, Math.PI * 2);
                ctx.fillStyle = this.dashing ? '#00ccff' : this.color;
                ctx.fill();
                ctx.restore();
            }

            ctx.save();
            ctx.translate(this.x + shakeX, this.y + shakeY);
            ctx.rotate(this.rotation);

            // Parry aura
            if (parryActive) {
                const time = Date.now() * 0.01;
                const pulse = Math.sin(time) * 0.1 + 1;
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 10 * pulse, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 10);
                gradient.addColorStop(0, 'rgba(0,255,100,0.3)');
                gradient.addColorStop(1, 'rgba(0,255,100,0)');
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Shield aura
            if (this.shieldHealth > 0) {
                const shieldPulse = Math.sin(Date.now() * 0.01) * 0.1 + 1;
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 5 * shieldPulse, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 5);
                gradient.addColorStop(0, 'rgba(0,204,255,0.3)');
                gradient.addColorStop(1, 'rgba(0,204,255,0)');
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Active buff aura
            if (currentBuff) {
                const buffPulse = Math.sin(Date.now() * 0.02) * 0.2 + 1;
                
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 15 * buffPulse, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius + 15);
                gradient.addColorStop(0, `${currentBuff.color}33`);
                gradient.addColorStop(1, `${currentBuff.color}00`);
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Body
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                -this.radius * 0.3, -this.radius * 0.3, 0,
                0, 0, this.radius
            );
            gradient.addColorStop(0, this.dashing ? '#00ccff' : '#ff335f');
            gradient.addColorStop(1, this.dashing ? '#0066ff' : '#cc0033');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Outer glow
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 3, 0, Math.PI * 2);
            ctx.strokeStyle = this.dashing ? '#00ccff' : '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Inner highlight
            ctx.beginPath();
            ctx.arc(this.radius * 0.3, -this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fill();

            // Gun indicator
            ctx.beginPath();
            ctx.moveTo(this.radius - 5, -5);
            ctx.lineTo(this.radius + 15, 0);
            ctx.lineTo(this.radius - 5, 5);
            ctx.closePath();
            ctx.fillStyle = '#333';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        shoot() {
            if (this.shootCooldown > 0) return;
            this.shootCooldown = weapons[currentWeapon].cooldown;
            shotsFired++;
            updateAccuracy();
    if (multiplayerMode) {
        multiplayerManager.updatePlayerAction('shoot');
    }
            const weapon = weapons[currentWeapon];
            const baseAngle = this.rotation;

            if (weapon.name === "SHOTGUN" || weapon.name === "AUTO SHOTGUN") {
                for (let i=0;i<weapon.pellets;i++){
                    const spread = (Math.random()-0.5)*(1 - weapon.precision) * 1.5;
                    this.fireBullet(baseAngle + spread, weapon);
                }
            } else {
                const spread = (Math.random()-0.5)*(1 - weapon.precision) * 0.3;
                this.fireBullet(baseAngle + spread, weapon);
            }

            // camera shake
            cameraShake = Math.max(cameraShake, weapon.name === "SHOTGUN" || weapon.name === "AUTO SHOTGUN" ? 8 : 5);
            screenShake(weapon.name === "SHOTGUN" || weapon.name === "AUTO SHOTGUN" ? 0.3 : 0.2);

            // Muzzle flash particles
            for (let i=0;i<(weapon.name==="SHOTGUN"||weapon.name==="AUTO SHOTGUN"?12:6); i++){
                const spread = (Math.random()-0.5)*0.3;
                particles.push(new Particle(
                    this.x + Math.cos(baseAngle)*this.radius,
                    this.y + Math.sin(baseAngle)*this.radius,
                    Math.cos(baseAngle + spread) * (8 + Math.random()*8),
                    Math.sin(baseAngle + spread) * (8 + Math.random()*8),
                    weapon.color,
                    2 + Math.random()*3,
                    0.25 + Math.random()*0.25,
                    true
                ));
            }
        }

        fireBullet(angle, weapon) {
            // Apply damage boost if active
            let damage = weapon.damage;
            if (currentBuff && currentBuff.name === "DAMAGE BOOST") {
                damage *= 2;
            }
            
            bullets.push(new Bullet(
                this.x + Math.cos(angle)*this.radius,
                this.y + Math.sin(angle)*this.radius,
                angle,
                weapon.speed,
                weapon.color,
                damage,
                weapon.pierce || false
            ));
        }

        dash() {
            if (dashCooldown > 0 || this.dashing) return;
            this.dashing = true;
            this.dashTime = this.dashDuration;
               if (multiplayerMode) {
        multiplayerManager.updatePlayerAction('dash');
    }
            // Apply shield cooldown bonus if active
            const cooldownModifier = this.shieldHealth > 0 ? (1 - shieldCooldownBonus) : 1;
            dashCooldown = 0.5 * cooldownModifier;
            this.invulnerable = true;
            setTimeout(() => { this.invulnerable = false; }, this.dashDuration * 1000);

            // dash particles
            const baseAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
            for (let i=0;i<22;i++){
                const spread = (Math.random()-0.5) * Math.PI;
                particles.push(new Particle(
                    this.x, this.y,
                    Math.cos(baseAngle + spread) * (10 + Math.random()*12),
                    Math.sin(baseAngle + spread) * (10 + Math.random()*12),
                    '#00ccff',
                    2 + Math.random()*3,
                    0.5 + Math.random()*0.4,
                    false
                ));
            }

            // Screen effect
            screenShake(0.3);
        }

        parry() {
            if (parryCooldown > 0 || parryActive) return;
            parryActive = true;
            parryTime = this.parryDuration;
            // Apply shield cooldown bonus if active
            const cooldownModifier = player.shieldHealth > 0 ? (1 - shieldCooldownBonus) : 1;
            parryCooldown = 1 * cooldownModifier;

            // Create parry explosion
            createExplosion(this.x, this.y, 100, '#00ff66', 0.7);
            screenShake(0.5);

            // Damage player and nearby enemies
            this.takeDamage(10); // 10% of max health

            // Damage all enemies in range
            for (const enemy of enemies) {
                const dist = distance(this.x, this.y, enemy.x, enemy.y);
                if (dist < 150) {
                    enemy.takeDamage(enemy.health * 0.4); // 40% of their health
                    
                    // Knockback
                    const angle = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                    enemy.x += Math.cos(angle) * 30;
                    enemy.y += Math.sin(angle) * 30;
                }
            }

            // Reflect nearby bullets
            for (const b of bullets) {
                const dx = b.x - this.x;
                const dy = b.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist < this.radius + 22) {
                    const angle = Math.atan2(dy, dx);
                    b.angle = angle + Math.PI;
                    b.speed *= 1.5;
                    b.color = '#00ff66';
                    increaseStyle(5);
                }
            }

            increaseStyle(10);
        }

        throwGrenade() {
            if (grenadeCooldown > 0) return;
            // Apply shield cooldown bonus if active
            const cooldownModifier = player.shieldHealth > 0 ? (1 - shieldCooldownBonus) : 1;
            grenadeCooldown = 3 * cooldownModifier;
            
            const angle = this.rotation;
            grenades.push(new Grenade(
                this.x + Math.cos(angle)*this.radius,
                this.y + Math.sin(angle)*this.radius,
                angle,
                8
            ));
        }

        convertEnemy() {
            if (convertCooldown > 0 || enemies.length === 0) return;
            // Apply shield cooldown bonus if active
            const cooldownModifier = player.shieldHealth > 0 ? (1 - shieldCooldownBonus) : 1;
            convertCooldown = 10 * cooldownModifier;
            
            // Find closest enemy
            let closestEnemy = null;
            let minDist = Infinity;
            for (const enemy of enemies) {
                const dist = distance(this.x, this.y, enemy.x, enemy.y);
                if (dist < minDist && dist < 200) {
                    minDist = dist;
                    closestEnemy = enemy;
                }
            }
            
            if (closestEnemy) {
                // Convert enemy to ally
                allies.push(new Ally(
                    closestEnemy.x,
                    closestEnemy.y,
                    closestEnemy.type
                ));
                
                // Remove from enemies
                enemies = enemies.filter(e => e !== closestEnemy);
                
                // Visual effect
                createExplosion(closestEnemy.x, closestEnemy.y, 80, '#00ff88', 0.6);
                screenShake(0.3);
                
                // Style points
                increaseStyle(15);
            }
        }

        takeDamage(amount) {
            if (this.invulnerable || currentBuff?.name === "INVULNERABILITY") return;
            
            // Apply damage multiplier for hard mode
            if (selectedModifiers.includes('hard-mode')) {
                amount *= 2;
            }
               if (multiplayerMode) {
        multiplayerManager.updatePlayerAction('hurt', { amount });
    }
            // Apply damage to shield first with damage reduction
            if (this.shieldHealth > 0) {
                const shieldDamage = amount * (1 - shieldDamageReduction);
                this.shieldHealth -= shieldDamage;
                if (this.shieldHealth < 0) {
                    // If shield is depleted, apply remaining damage to health
                    amount = -this.shieldHealth / (1 - shieldDamageReduction);
                    this.shieldHealth = 0;
                    shieldEffect.style.opacity = '0';
                } else {
                    amount = 0;
                }
                shieldBar.style.width = `${(this.shieldHealth / this.maxShieldHealth) * 100}%`;
            }
            
            // Apply remaining damage to health
            if (amount > 0) {
                this.health -= amount;
                this.health = Math.max(0, this.health);
                healthFill.style.width = `${(this.health / this.maxHealth) * 100}%`;
            }

            // Blood overlay effect
            bloodIntensity = Math.min(bloodIntensity + 0.3, 1.0);
            bloodOverlay.style.opacity = bloodIntensity;
            setTimeout(() => {
                bloodIntensity = Math.max(bloodIntensity - 0.05, 0);
                bloodOverlay.style.opacity = bloodIntensity;
            }, 300);

            cameraShake = Math.max(cameraShake, 10);
            screenShake(0.3);

            combo = 0;
            comboCount.textContent = combo;

            if (this.health <= 0) gameOver();
        }

        addShield(amount) {
            this.shieldHealth = Math.min(this.maxShieldHealth, this.shieldHealth + amount);
            shieldBar.style.width = `${(this.shieldHealth / this.maxShieldHealth) * 100}%`;
            
            // Show shield effect if shield is active
            if (this.shieldHealth > 0) {
                shieldEffect.style.opacity = '1';
            }
            
            // Shield gain effect
            for (let i=0;i<8;i++){
                particles.push(new Particle(
                    this.x, this.y,
                    (Math.random()-0.5)*3, (Math.random()-0.5)*3,
                    '#00ccff', 2 + Math.random()*2, 0.8 + Math.random()*0.6,
                    false
                ));
            }
        }

        heal(amount) {
            // If health is already full, add to shield instead
            if (this.health >= this.maxHealth) {
                this.addShield(amount);
                return;
            }
            
            this.health = Math.min(this.maxHealth, this.health + amount);
            healthFill.style.width = `${(this.health / this.maxHealth) * 100}%`;
            for (let i=0;i<6;i++){
                particles.push(new Particle(
                    this.x, this.y,
                    (Math.random()-0.5)*3, (Math.random()-0.5)*3,
                    '#ff003c', 2 + Math.random()*2, 0.8 + Math.random()*0.6,
                    false
                ));
            }
        }
    }

    // Ally class (converted enemies)
        // Add this class to your existing code
class MultiplayerPlayer {
    constructor(id, name, x, y, color) {
        this.id = id;
        this.name = name;
        this.x = x;
        this.y = y;
        this.radius = 20;
        this.color = color || this.generateColorFromId(id);
        this.health = 100;
        this.rotation = 0;
        this.trail = [];
        this.trailLength = 10;
    }
       
    showAction(action) {
        // Visual feedback for player actions
        switch(action) {
            case 'shoot':
                this.muzzleFlash = 1.0;
                break;
            case 'dash':
                this.dashEffect = 1.0;
                break;
            case 'hurt':
                this.hurtEffect = 1.0;
                break;
        }
    }

    generateColorFromId(id) {
        // Generate a consistent color based on player ID
        const colors = ['#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
        const index = id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % colors.length;
        return colors[index];
    }

    update(data) {
        
        this.x = data.x;
        this.y = data.y;
        this.health = data.health;
        this.rotation = data.rotation || 0;
        
        // Add trail point
        this.trail.push({x: this.x, y: this.y, life: 1});
        if (this.trail.length > this.trailLength) this.trail.shift();
        
        // Update trail
        for (let i = 0; i < this.trail.length; i++) {
            this.trail[i].life -= 0.05;
        }
        this.trail = this.trail.filter(point => point.life > 0);
        if (this.muzzleFlash > 0) this.muzzleFlash -= 0.1;
        if (this.dashEffect > 0) this.dashEffect -= 0.05;
        if (this.hurtEffect > 0) this.hurtEffect -= 0.08;
    }draw() {
    const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
    const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;

    // Draw trail
    for (let i = 0; i < this.trail.length; i++) {
        const point = this.trail[i];
        const alpha = point.life * 0.3;
        const size = this.radius * (i / this.trail.length) * 0.8;
        
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(point.x + shakeX, point.y + shakeY, size, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
    }

    ctx.save();
    ctx.translate(this.x + shakeX, this.y + shakeY);
    ctx.rotate(this.rotation);

    // Draw player body
    ctx.beginPath();
    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
    
    // Create gradient
    const gradient = ctx.createRadialGradient(
        -this.radius * 0.3, -this.radius * 0.3, 0,
        0, 0, this.radius
    );
    gradient.addColorStop(0, this.color);
    gradient.addColorStop(1, convertToRgba(this.color, 0.7));
    
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // Outer glow
    ctx.beginPath();
    ctx.arc(0, 0, this.radius + 3, 0, Math.PI * 2);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw muzzle flash
    if (this.muzzleFlash > 0) {
        ctx.save();
        ctx.globalAlpha = this.muzzleFlash;
        ctx.beginPath();
        ctx.arc(
            Math.cos(this.rotation) * this.radius, 
            Math.sin(this.rotation) * this.radius, 
            8 * this.muzzleFlash, 
            0, 
            Math.PI * 2
        );
        ctx.fillStyle = '#ffcc00';
        ctx.fill();
        ctx.restore();
    }
    
    // Draw dash effect
    if (this.dashEffect > 0) {
        ctx.save();
        ctx.globalAlpha = this.dashEffect * 0.3;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 15 * this.dashEffect, 0, Math.PI * 2);
        ctx.fillStyle = '#00ccff';
        ctx.fill();
        ctx.restore();
    }
    
    // Draw hurt effect
    if (this.hurtEffect > 0) {
        ctx.save();
        ctx.globalAlpha = this.hurtEffect * 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
        ctx.fillStyle = '#ff0000';
        ctx.fill();
        ctx.restore();
    }
    
    // Draw player name and health bar without rotation
    ctx.save();
    ctx.rotate(-this.rotation); // Counteract the player rotation
    
    // Draw player name
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px VT323';
    ctx.textAlign = 'center';
    ctx.fillText(this.name, 0, -this.radius - 15);
    
    // Draw health bar
    const barWidth = this.radius * 2;
    const healthPercent = this.health / 100;
    ctx.fillStyle = '#330000';
    ctx.fillRect(-barWidth/2, -this.radius - 10, barWidth, 5);
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(-barWidth/2, -this.radius - 10, barWidth * healthPercent, 5);
    
    ctx.restore(); // Restore to rotated state
    
    ctx.restore(); // Restore to original state
}
    class Ally {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.radius = type === 'FILTH' ? 15 : type === 'SCHISM' ? 25 : type === 'IDOL' ? 20 : type === 'TITAN' ? 40 : 30;
            this.color = type === 'FILTH' ? '#6666ff' : type === 'SCHISM' ? '#ff3333' : type === 'IDOL' ? '#ffff00' : type === 'TITAN' ? '#ff6600' : '#9900ff';
            this.speed = type === 'FILTH' ? 2 : type === 'SCHISM' ? 3 : type === 'IDOL' ? 1.5 : type === 'TITAN' ? 1 : 2.5;
            this.health = type === 'FILTH' ? 3 : type === 'SCHISM' ? 8 : type === 'IDOL' ? 5 : type === 'TITAN' ? 20 : 15;
            this.attackCooldown = 0;
            this.target = null;
            this.pulse = 0;
        }

        update(deltaTime) {
            // Find closest enemy
            this.target = null;
            let minDist = Infinity;
            for (const enemy of enemies) {
                const dist = distance(this.x, this.y, enemy.x, enemy.y);
                if (dist < minDist) {
                    minDist = dist;
                    this.target = enemy;
                }
            }

            // Move toward target or follow player if no target
            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            } else if (player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 100) { // Don't get too close to player
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }

            // Attack cooldown
            if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;

            // Attack if close to target
            if (this.target && this.attackCooldown <= 0) {
                const dist = distance(this.x, this.y, this.target.x, this.target.y);
                if (dist < this.radius + this.target.radius + 10) {
                    this.target.takeDamage(2); // Ally damage
                    this.attackCooldown = 1;
                }
            }
    // Multiplayer collision avoidance
    if (multiplayerMode) {
        for (const playerId in window.multiplayerPlayerObjects) {
            if (playerId !== playerId) {
                const otherPlayer = window.multiplayerPlayerObjects[playerId];
                const dist = distance(this.x, this.y, otherPlayer.x, otherPlayer.y);
                if (dist < this.radius + otherPlayer.radius + 10) {
                    // Push away from other player
                    const angle = Math.atan2(this.y - otherPlayer.y, this.x - otherPlayer.x);
                    this.x += Math.cos(angle) * 0.5;
                    this.y += Math.sin(angle) * 0.5;
                }
            }
        }
    }
            // Update pulse effect
            this.pulse = (this.pulse + deltaTime * 2) % (Math.PI * 2);
        }

        draw() {
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;

            ctx.save();
            ctx.translate(this.x + shakeX, this.y + shakeY);

            // Draw ally body with pulse effect
            const pulseSize = Math.sin(this.pulse) * 2;
            
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + pulseSize, 0, Math.PI * 2);
            
            // Ally color (green tint to show it's friendly)
            const gradient = ctx.createRadialGradient(
                -this.radius * 0.3, -this.radius * 0.3, 0,
                0, 0, this.radius + pulseSize
            );
            gradient.addColorStop(0, this.color.replace(')', ', 0.8)').replace('rgb', 'rgba'));
            gradient.addColorStop(1, '#00ff00');
            
            ctx.fillStyle = gradient;
            ctx.fill();

            // Outer glow (green for allies)
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + pulseSize + 3, 0, Math.PI * 2);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw a ring to indicate it's an ally
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2);
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.restore();
        }

        takeDamage(amount) {
            this.health -= amount;
            if (this.health <= 0) {
                // Create death effect
                createExplosion(this.x, this.y, 50, '#00ff00', 0.5);
                return true;
            }
            return false;
        }
    }

    // Enemy class
    class Enemy {
        constructor(x,y,type){
            this.x = x; this.y = y; this.type = type;
            this.baseSpeed = 1.5;
            
            if (type === 'FILTH') { 
                this.radius=15; this.speed=this.baseSpeed*1.25; this.health=3; 
                this.color='#6666ff'; this.damage=10; this.score=100; 
            }
            else if (type === 'SCHISM') { 
                this.radius=25; this.speed=this.baseSpeed*2; this.health=8; 
                this.color='#ff3333'; this.damage=15; this.score=200; 
            }
            else if (type === 'IDOL') { 
                this.radius=20; this.speed=this.baseSpeed*1.2; this.health=5; 
                this.color='#ffff00'; this.damage=5; this.score=300; this.buffRadius=150; 
            }
            else if (type === 'TITAN') { 
                this.radius=40; this.speed=this.baseSpeed*0.8; this.health=20; 
                this.color='#ff6600'; this.damage=25; this.score=500;
            }
            else if (type === 'NIGHTMARE') { 
                this.radius=30; this.speed=this.baseSpeed*1.5; this.health=15; 
                this.color='#9900ff'; this.damage=20; this.score=800;
                this.teleportCooldown = 3;
                this.teleportTimer = 0;
            }
            
            this.attackCooldown = 0;
            this.buffing = false;
            this.hitFlash = 0;
            this.pulse = 0;
        }

        update(deltaTime){
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist === 0) dist = 0.0001;

            if (this.type === 'IDOL') {
                this.buffing = false;
                // reset speed to base scaled by difficulty
                this.speed = this.baseSpeed * (1 + 0.1 * difficulty);

                for (const enemy of enemies) {
                    if (enemy !== this && enemy.type !== 'IDOL') {
                        const edx = enemy.x - this.x;
                        const edy = enemy.y - this.y;
                        const edist = Math.hypot(edx, edy);
                        if (edist < this.buffRadius) {
                            enemy.speed = enemy.baseSpeed * (enemy.type === 'FILTH' ? 2.5 * difficulty : 2 * difficulty);
                            this.buffing = true;
                        }
                    }
                }

                if (!this.buffing) {
                    // approach but slowly
                    if (dist > 200) {
                        this.x += (dx / dist) * this.speed * 0.6;
                        this.y += (dy / dist) * this.speed * 0.6;
                    } else if (dist < 150) {
                        this.x -= (dx / dist) * this.speed * 0.6;
                        this.y -= (dy / dist) * this.speed * 0.6;
                    }
                }
            } 
            else if (this.type === 'NIGHTMARE') {
                // Teleport behavior
                this.teleportTimer -= deltaTime;
                if (this.teleportTimer <= 0 && dist < 200) {
                    // Teleport behind player
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x = player.x - Math.cos(angle) * 100;
                    this.y = player.y - Math.sin(angle) * 100;
                    this.teleportTimer = this.teleportCooldown;
                    
                    // Teleport effect
                    for (let i=0;i<20;i++){
                        particles.push(new Particle(
                            this.x, this.y,
                            (Math.random()-0.5)*5, (Math.random()-0.5)*5,
                            '#9900ff', 2 + Math.random()*3, 0.5 + Math.random()*0.5,
                            false
                        ));
                    }
                } else {
                    // Normal movement
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }
            else {
                // ensure speed is appropriate
                this.speed = this.baseSpeed * (this.type === 'FILTH' ? 2 * difficulty : 1.5 * difficulty);
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }

            if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;

            const contactDist = Math.hypot(player.x - this.x, player.y - this.y);
            if (contactDist < this.radius + player.radius && this.attackCooldown <= 0) {
                player.takeDamage(this.damage);
                this.attackCooldown = 1;
                createBloodSplat(player.x, player.y);
            }

            // Update effects
            if (this.hitFlash > 0) this.hitFlash -= deltaTime * 5;
            this.pulse = (this.pulse + deltaTime * 2) % (Math.PI * 2);
        }

        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;

            ctx.save();
            ctx.translate(this.x + shakeX, this.y + shakeY);

            // Draw health bar
            const barWidth = this.radius * 2;
            const healthPercent = this.health / (this.type === 'FILTH' ? 3 : this.type === 'SCHISM' ? 8 : this.type === 'IDOL' ? 5 : this.type === 'TITAN' ? 20 : 15);
            ctx.fillStyle = '#330000';
            ctx.fillRect(-barWidth/2, -this.radius - 10, barWidth, 5);
            ctx.fillStyle = '#ff003c';
            ctx.fillRect(-barWidth/2, -this.radius - 10, barWidth * healthPercent, 5);

            // Draw enemy body with pulse effect
            const pulseSize = Math.sin(this.pulse) * 2;
            
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + pulseSize, 0, Math.PI * 2);
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                -this.radius * 0.3, -this.radius * 0.3, 0,
                0, 0, this.radius + pulseSize
            );
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(1, this.type === 'FILTH' ? '#3333aa' : 
                                this.type === 'SCHISM' ? '#aa0000' : 
                                this.type === 'IDOL' ? '#aaaa00' :
                                this.type === 'TITAN' ? '#cc5500' : '#6600aa');
            
            ctx.fillStyle = gradient;
            ctx.fill();

            // Hit flash
            if (this.hitFlash > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + pulseSize + 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.hitFlash})`;
                ctx.fill();
            }

            // Outer glow
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + pulseSize + 3, 0, Math.PI * 2);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.stroke();

            if (this.type === 'SCHISM') {
                ctx.beginPath();
                ctx.arc(0, 0, this.radius - 5 + pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                for (let i=0;i<8;i++){
                    const a = (i/8)*Math.PI*2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(a)*(this.radius-3), Math.sin(a)*(this.radius-3));
                    ctx.lineTo(Math.cos(a)*(this.radius+5), Math.sin(a)*(this.radius+5));
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            } else if (this.type === 'IDOL') {
                ctx.beginPath();
                ctx.arc(0, 0, this.radius-3 + pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.stroke();
                if (this.buffing) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius+5 + pulseSize, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5,5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            } else if (this.type === 'TITAN') {
                ctx.beginPath();
                ctx.arc(0, 0, this.radius-5 + pulseSize, 0, Math.PI * 2);
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 3;
                ctx.stroke();
                // Spikes
                for (let i=0;i<12;i++){
                    const a = (i/12)*Math.PI*2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(a)*(this.radius-5), Math.sin(a)*(this.radius-5));
                    ctx.lineTo(Math.cos(a)*(this.radius+8), Math.sin(a)*(this.radius+8));
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            } else if (this.type === 'NIGHTMARE') {
                // Glowing eyes
                ctx.beginPath();
                ctx.arc(-this.radius*0.4, -this.radius*0.3, this.radius*0.2, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.radius*0.4, -this.radius*0.3, this.radius*0.2, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(-this.radius*0.4, -this.radius*0.3, this.radius*0.1, 0, Math.PI * 2);
                ctx.fillStyle = '#000000';
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.radius*0.4, -this.radius*0.3, this.radius*0.1, 0, Math.PI * 2);
                ctx.fillStyle = '#000000';
                ctx.fill();
            }

            ctx.restore();
        }

        takeDamage(amount){
            this.health -= amount;
            this.hitFlash = 1;
            
            for (let i=0;i<8;i++){
                particles.push(new Particle(
                    this.x, this.y,
                    (Math.random()-0.5)*5, (Math.random()-0.5)*5,
                    '#ff003c', 2 + Math.random()*2, 0.5 + Math.random()*0.6,
                    false
                ));
            }
            
            if (this.health <= 0) {
                for (let i=0;i<5;i++){
                    bloodDrops.push(new BloodDrop(this.x + (Math.random()-0.5)*20, this.y + (Math.random()-0.5)*20));
                }

                // Double style points if in substage 1
                const styleMultiplier = substage === 1 ? 2 : 1;
                const points = Math.round(this.score * (styleLevel + 1) * (combo > 0 ? combo : 1));
                score += points;
                scoreDisplay.textContent = `SCORE: ${score}`;

                kills++;
                killCount.textContent = kills;

                // Add shield based on enemy type (10% of enemy's max health)
                const shieldGain = enemyHealthValues[this.type] * 0.1 * (1 + (kills / 100));
                player.addShield(shieldGain);

                // Increase play area size with kills (up to 2x)
                playAreaSize = Math.min(2, 1 + (kills * 0.0005));
                
                // Increase zoom level with kills
                zoomLevel = Math.max(0.5, 1.0 - (kills * 0.0005));
                gameContainer.style.transform = `scale(${zoomLevel})`;

                increaseCombo();
                increaseStyle(3 * styleMultiplier);
                createBloodSplat(this.x, this.y);

                cameraShake = Math.max(cameraShake, 8);
                screenShake(0.2);
                
                // Check for stage progression
                checkStageProgression();
                
                return true;
            }
            return false;
        }
    }

    // Obstacle class
    class Obstacle {
        constructor(type) {
            const bounds = getPlayAreaBounds();
            this.x = bounds.minX + Math.random() * (bounds.maxX - bounds.minX);
            this.y = bounds.minY + Math.random() * (bounds.maxY - bounds.minY);
            this.type = type;
            
            if (this.type === 'SPIKE') {
                this.radius = 15;
                this.damage = 5;
                this.color = '#ff0000';
            } else if (this.type === 'LASER') {
                this.radius = 10;
                this.damage = 2;
                this.color = '#00ffff';
                this.laserActive = true;
                this.laserTimer = 0;
            } else if (this.type === 'MINE') {
                this.radius = 8;
                this.damage = 15;
                this.color = '#ffff00';
                this.triggered = false;
                this.explodeTimer = 0;
            }
            
            this.pulse = 0;
        }

        update(deltaTime) {
            // Laser obstacle behavior
            if (this.type === 'LASER') {
                this.laserTimer += deltaTime;
                if (this.laserTimer >= 2) {
                    this.laserActive = !this.laserActive;
                    this.laserTimer = 0;
                }
            }
            
            // Mine obstacle behavior
            if (this.type === 'MINE' && this.triggered) {
                this.explodeTimer += deltaTime;
                if (this.explodeTimer >= 0.5) {
                    createExplosion(this.x, this.y, 80, '#ffff00', 0.7);
                    // Damage player if nearby
                    if (player && distance(this.x, this.y, player.x, player.y) < 100) {
                        player.takeDamage(this.damage);
                    }
                    return true; // Remove after explosion
                }
            }
            
            // Check collision with player
            if (player && this.type !== 'MINE') {
                const dist = distance(this.x, this.y, player.x, player.y);
                if (dist < this.radius + player.radius) {
                    player.takeDamage(this.damage);
                    
                    // Trigger mine if it's a mine
                    if (this.type === 'MINE' && !this.triggered) {
                        this.triggered = true;
                        this.color = '#ff0000';
                    }
                }
            }
            
            // Update pulse effect
            this.pulse = (this.pulse + deltaTime * 3) % (Math.PI * 2);
            
            return false;
        }

        draw() {
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            
            ctx.save();
            ctx.translate(this.x + shakeX, this.y + shakeY);
            
            const pulseSize = Math.sin(this.pulse) * 2;
            
            if (this.type === 'SPIKE') {
                // Draw spike obstacle
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + pulseSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Draw spikes
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(
                        Math.cos(angle) * (this.radius + 8 + pulseSize),
                        Math.sin(angle) * (this.radius + 8 + pulseSize)
                    );
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            } else if (this.type === 'LASER') {
                // Draw laser emitter
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + pulseSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Draw laser if active
                if (this.laserActive) {
                    const bounds = getPlayAreaBounds();
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const length = 1000; // Long laser
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(
                        Math.cos(angle) * length,
                        Math.sin(angle) * length
                    );
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw laser glow
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(
                        Math.cos(angle) * length,
                        Math.sin(angle) * length
                    );
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.lineWidth = 10;
                    ctx.stroke();
                }
            } else if (this.type === 'MINE') {
                // Draw mine
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + pulseSize, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Draw warning dots
                if (this.triggered) {
                    const blink = Math.sin(Date.now() * 0.02) > 0;
                    if (blink) {
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                    }
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius - 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#000000';
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
    }

    // Bullet class
    class Bullet {
        constructor(x,y,angle,speed,color,damage,pierce=false){
            this.x=x; this.y=y; this.angle=angle; this.speed=speed; this.radius=3; this.color=color; this.damage=damage;
            this.pierce = pierce;
            this.trail = [];
            this.trailLength = 5;
        }
        update(){
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            
            // Add trail point
            this.trail.push({x: this.x, y: this.y});
            if (this.trail.length > this.trailLength) this.trail.shift();
            
            // trail particles
            particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*2, (Math.random()-0.5)*2, this.color, 1 + Math.random()*2, 0.22, true));
            
            // out of bounds
            const bounds = getPlayAreaBounds();
            if (this.x < bounds.minX - 20 || this.x > bounds.maxX + 20 || 
                this.y < bounds.minY - 20 || this.y > bounds.maxY + 20) return true;
            return false;
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            
            // Draw trail
            for (let i = 0; i < this.trail.length; i++) {
                const point = this.trail[i];
                const alpha = (i / this.trail.length) * 0.5;
                const size = this.radius * (i / this.trail.length);
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(point.x + shakeX, point.y + shakeY, size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
            
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius, 0, Math.PI * 2);
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                this.x - 2, this.y - 2, 0,
                this.x, this.y, this.radius
            );
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(1, this.color.replace(')', ', 0.5)').replace('rgb', 'rgba'));
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Glow effect
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius + 3, 0, Math.PI * 2);
            ctx.fillStyle = this.color.replace(')', ', 0.2)').replace('rgb', 'rgba');
            ctx.fill();
            
            ctx.restore();
        }
    }

    // Grenade class
    class Grenade {
        constructor(x,y,angle,speed){
            this.x=x; this.y=y; this.angle=angle; this.speed=speed; this.radius=5; 
            this.color='#ff6600'; this.timer=2.0; this.exploded=false;
        }
        update(deltaTime){
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            this.speed *= 0.98; // friction
            
            this.timer -= deltaTime;
            if (this.timer <= 0 && !this.exploded) {
                this.explode();
            }
            
            // out of bounds
            const bounds = getPlayAreaBounds();
            if (this.x < bounds.minX - 20 || this.x > bounds.maxX + 20 || 
                this.y < bounds.minY - 20 || this.y < bounds.maxY + 20) {
                this.explode();
            }
            
            return this.exploded;
        }
        explode(){
            this.exploded = true;
            createExplosion(this.x, this.y, 120, '#ff6600', 0.8);
            screenShake(0.5);
            
            // Damage all enemies in range
            let hitEnemies = false;
            for (const enemy of enemies) {
                const dist = distance(this.x, this.y, enemy.x, enemy.y);
                if (dist < 120) {
                    hitEnemies = true;
                    const damage = 15 * (1 - dist/120);
                    enemy.takeDamage(damage);
                    
                    // Knockback
                    const angle = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                    enemy.x += Math.cos(angle) * 20;
                    enemy.y += Math.sin(angle) * 20;
                }
            }
            
            // Damage all obstacles in range
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const dist = distance(this.x, this.y, obstacle.x, obstacle.y);
                if (dist < 120) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Only increase style if enemies were hit
            if (hitEnemies) {
                increaseStyle(5);
            }
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius, 0, Math.PI * 2);
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                this.x - 2, this.y - 2, 0,
                this.x, this.y, this.radius
            );
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(1, '#ff3300');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Fuse spark
            const sparkSize = Math.sin(Date.now() * 0.02) * 2 + 2;
            ctx.beginPath();
            ctx.arc(this.x + Math.cos(this.angle)*this.radius + shakeX, 
                   this.y + Math.sin(this.angle)*this.radius + shakeY, 
                   sparkSize, 0, Math.PI * 2);
            ctx.fillStyle = '#ffcc00';
            ctx.fill();
            
            ctx.restore();
        }
    }

    // BloodDrop class
    class BloodDrop {
        constructor(x,y){ 
            this.x=x; this.y=y; this.radius=5; this.color='#ff003c'; this.life=10; 
            this.pulse = 0;
        }
        update(){
            this.life -= 0.016;
            this.pulse = (this.pulse + 0.1) % (Math.PI * 2);
            if (this.life <= 0) return true;
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist < this.radius + player.radius) {
                player.heal(10);
                increaseStyle(1);
                for (let i=0;i<6;i++){
                    particles.push(new Particle(this.x, this.y, (Math.random()-0.5)*3, (Math.random()-0.5)*3, '#ff003c', 1 + Math.random()*2, 0.5, false));
                }
                return true;
            }
            return false;
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const pulse = Math.sin(this.pulse) * 1.5;
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius + pulse, 0, Math.PI * 2);
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                this.x - 2, this.y - 2, 0,
                this.x, this.y, this.radius + pulse
            );
            gradient.addColorStop(0, '#ff335f');
            gradient.addColorStop(1, '#cc0033');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.globalAlpha = 0.28;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, this.radius + pulse + 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,0,60,0.3)';
            ctx.fill();
            ctx.restore();
            ctx.globalAlpha = 1;
        }
    }

    // Particle class
    class Particle {
        constructor(x,y,vx,vy,color,size,life,useNoise){
            this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.color=color; this.size=size; this.life=life; this.maxLife=life;
            this.useNoise = useNoise;
            this.noiseOffset = Math.random() * 100;
        }
        update(){
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.016;
            this.vx *= 0.95; this.vy *= 0.95;
            
            return this.life <= 0;
        }
        draw(){
            const shakeX = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const shakeY = cameraShake > 0 ? (Math.random()-0.5) * cameraShake : 0;
            const alpha = clamp(this.life / this.maxLife, 0, 1);
            const currentSize = this.size * alpha;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(this.x + shakeX, this.y + shakeY, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }
    }

    // Helper functions
    function getPlayAreaBounds() {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const width = canvas.width * playAreaSize;
        const height = canvas.height * playAreaSize;
        
        return {
            minX: centerX - width/2,
            maxX: centerX + width/2,
            minY: centerY - height/2,
            maxY: centerY + height/2
        };
    }

    function drawPlayAreaBounds() {
        const bounds = getPlayAreaBounds();
        ctx.save();
        ctx.strokeStyle = '#ff003c';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
        ctx.setLineDash([]);
        ctx.restore();
    }

    function createExplosion(x, y, size, color, intensity) {
        explosions.push({x, y, size, color, intensity, life: 1.0});
        screenShake(intensity);
        
        // Explosion particles
        for (let i=0;i<30;i++){
            const angle = Math.random() * Math.PI * 2;
            const speed = 5 + Math.random()*10;
            particles.push(new Particle(
                x, y,
                Math.cos(angle)*speed, Math.sin(angle)*speed,
                color, 3 + Math.random()*4, 0.5 + Math.random()*0.5,
                false
            ));
        }
    }

    function createBloodSplat(x,y){
        // Increase blood intensity
        bloodIntensity = Math.min(bloodIntensity + 0.2, 1.0);
        bloodOverlay.style.opacity = bloodIntensity;
        setTimeout(() => {
            bloodIntensity = Math.max(bloodIntensity - 0.02, 0);
            bloodOverlay.style.opacity = bloodIntensity;
        }, 1000);
        
        // Blood particles
        for (let i=0;i<10;i++){
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random()*5;
            particles.push(new Particle(
                x, y,
                Math.cos(angle)*speed, Math.sin(angle)*speed,
                '#ff003c', 2 + Math.random()*3, 0.5 + Math.random()*0.5,
                false
            ));
        }
    }

    function screenShake(intensity) {
        cameraShake = intensity * 10;
        cameraOffset.x = (Math.random() - 0.5) * intensity * 20;
        cameraOffset.y = (Math.random() - 0.5) * intensity * 20;
        cameraZoom = 1.0 - intensity * 0.1;
        
        // Chromatic aberration effect
        chromaticAberration.style.boxShadow = `
            ${intensity * 4}px 0 0 rgba(255, 0, 0, ${intensity * 0.3}),
            -${intensity * 4}px 0 0 rgba(0, 0, 255, ${intensity * 0.3}),
            0 ${intensity * 4}px 0 rgba(0, 255, 0, ${intensity * 0.3})
        `;
    }

    function drawAimLine() {
        if (!player || !gameActive) return;
        
        const angle = player.rotation;
        const length = 200;
        const endX = player.x + Math.cos(angle) * length;
        const endY = player.y + Math.sin(angle) * length;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = 'rgba(255, 204, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }

    function updateCrosshair() {
        crosshair.style.left = `${mouse.x - 10}px`;
        crosshair.style.top = `${mouse.y - 10}px`;
    }

    // Style system
    function increaseStyle(amount){
        stylePoints += amount;
        // find new level
        let newLevel = 0;
        for (let i = styleThresholds.length - 1; i >= 0; i--) {
            if (stylePoints >= styleThresholds[i]) { newLevel = i; break; }
        }
        if (newLevel > styleLevel) {
            cameraShake = Math.max(cameraShake, 12);
            screenShake(0.3);
        }
        styleLevel = newLevel;
        styleMeter.textContent = styleRankings[styleLevel] || styleRankings[styleRankings.length - 1];

        const nextThreshold = styleLevel < styleThresholds.length - 1 ? styleThresholds[styleLevel + 1] : styleThresholds[styleLevel] * 2;
        const progress = (stylePoints - styleThresholds[styleLevel]) / Math.max(1, (nextThreshold - styleThresholds[styleLevel]));
        styleFill.style.width = `${clamp(progress, 0, 1) * 100}%`;

        if (styleTimeout) clearTimeout(styleTimeout);
        startStyleDecay();
    }
    function startStyleDecay() {
        if (stylePoints <= 0) return;
        const decayRate = 0.12 / (1 + difficulty * 0.5);
        styleTimeout = setTimeout(() => {
            stylePoints = Math.max(0, stylePoints - decayRate);
            // update display
            let newLevel = 0;
            for (let i = styleThresholds.length - 1; i >= 0; i--) {
                if (stylePoints >= styleThresholds[i]) { newLevel = i; break; }
            }
                        styleLevel = newLevel;
            styleMeter.textContent = styleRankings[styleLevel];
            const nextThreshold = styleLevel < styleThresholds.length - 1 ? styleThresholds[styleLevel + 1] : styleThresholds[styleLevel] * 2;
            const progress = styleLevel > 0 ? (stylePoints - styleThresholds[styleLevel]) / Math.max(1, (nextThreshold - styleThresholds[styleLevel])) : stylePoints / Math.max(1, nextThreshold);
            styleFill.style.width = `${clamp(progress,0,1) * 100}%`;
            if (stylePoints > 0) startStyleDecay();
        }, 120);
    }

    // Combo system
    function increaseCombo(){
        combo++;
        comboCount.textContent = combo;
        if (combo > maxCombo) maxCombo = combo;
        if (combo % 5 === 0) {
            screenShake(0.2);
        }
        if (comboTimeout) clearTimeout(comboTimeout);
        comboTimeout = setTimeout(()=>{ combo=0; comboCount.textContent=combo; }, 3000);
    }

    // Accuracy system
    function updateAccuracy(){
        const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 100;
        accuracyDisplay.textContent = `${accuracy}%`;
    }

    // Enemy spawning
    function spawnEnemy(deltaTime) {
        enemySpawnTimer -= deltaTime;
        if (enemySpawnTimer <= 0) {
            // Determine stage based on score
            if (!infiniteMode) {
                stage = Math.min(5, Math.floor(score / 1000) + 1);
            } else {
                // Infinite mode - stages keep increasing
                stage = Math.floor(score / 1000) + 1;
            }
            
            // Scale difficulty based on player count in multiplayer
            const playerCount = multiplayerMode ? Object.keys(multiplayerPlayers).length : 1;
            difficulty = 1 + (stage * 0.2) + (playerCount * 0.2);
            
            // For stages beyond 5, use random enemy types from all available
            let enemyTypes;
            if (stage <= 5) {
                enemyTypes = enemyTypesByStage[stage];
            } else {
                // Infinite mode - mix all enemy types with increasing difficulty
                enemyTypes = ['FILTH', 'SCHISM', 'IDOL', 'TITAN', 'NIGHTMARE'];
                // Higher stages have higher chance of stronger enemies
                if (stage > 7) {
                    enemyTypes = ['SCHISM', 'IDOL', 'TITAN', 'NIGHTMARE'];
                }
                if (stage > 10) {
                    enemyTypes = ['IDOL', 'TITAN', 'NIGHTMARE'];
                }
                if (stage > 15) {
                    enemyTypes = ['TITAN', 'NIGHTMARE'];
                }
            }
            
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            
            const bounds = getPlayAreaBounds();
            const side = Math.floor(Math.random() * 4);
            let x,y;
            switch(side){
                case 0: x = bounds.minX - 40; y = bounds.minY + Math.random()*(bounds.maxY - bounds.minY); break;
                case 1: x = bounds.maxX + 40; y = bounds.minY + Math.random()*(bounds.maxY - bounds.minY); break;
                case 2: x = bounds.minX + Math.random()*(bounds.maxX - bounds.minX); y = bounds.minY - 40; break;
                default: x = bounds.minX + Math.random()*(bounds.maxX - bounds.minX); y = bounds.maxY + 40; break;
            }
            enemies.push(new Enemy(x,y,enemyType));
            
            // Spawn timer based on difficulty
            enemySpawnTimer = Math.max(0.5, 2.0 - (stage * 0.2));
            
            // Update game state in multiplayer (host only)
            if (multiplayerMode && isHost) {
                multiplayerManager.updateGameState();
            }
        }
    }

    // Obstacle spawning (for substages)
    function spawnObstacle() {
        if (substage === 0) return; // No obstacles in base stage
        
        const obstacleTypes = ['SPIKE', 'LASER', 'MINE'];
        const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
        obstacles.push(new Obstacle(type));
        
        // Update game state in multiplayer (host only)
        if (multiplayerMode && isHost) {
            multiplayerManager.updateGameState();
        }
    }

    // Apply random buff
    function applyRandomBuff() {
        if (!selectedModifiers.includes('random-buff')) return;
        
        // Clear any existing buff
        if (currentBuff) {
            currentBuff.revert(player);
        }
        
        // Select a random buff
        currentBuff = {...buffTypes[Math.floor(Math.random() * buffTypes.length)]};
        currentBuff.effect(player);
        buffTimer = currentBuff.duration;
        
        // Visual effect
        createExplosion(player.x, player.y, 150, currentBuff.color, 0.5);
        screenShake(0.3);
        
        // Display buff notification
        const notification = document.createElement('div');
        notification.style.position = 'absolute';
        notification.style.top = '50%';
        notification.style.left = '50%';
        notification.style.transform = 'translate(-50%, -50%)';
        notification.style.color = currentBuff.color;
        notification.style.fontSize = '32px';
        notification.style.fontWeight = 'bold';
        notification.style.textShadow = '2px 2px 0 #000';
        notification.style.zIndex = '100';
        notification.style.opacity = '0';
        notification.textContent = currentBuff.name + '!';
        document.body.appendChild(notification);
        
        // Animate notification
        let opacity = 0;
        const fadeIn = setInterval(() => {
            opacity += 0.05;
            notification.style.opacity = opacity;
            if (opacity >= 1) {
                clearInterval(fadeIn);
                setTimeout(() => {
                    const fadeOut = setInterval(() => {
                        opacity -= 0.05;
                        notification.style.opacity = opacity;
                        if (opacity <= 0) {
                            clearInterval(fadeOut);
                            document.body.removeChild(notification);
                        }
                    }, 50);
                }, 1500);
            }
        }, 50);
    }

    // Stage progression
    function checkStageProgression() {
        // Every 10 kills, consider progressing stage or substage
        if (kills % 10 === 0 && kills > 0) {
            // Every 30 kills, increase main stage
            if (kills % 30 === 0) {
                stage++;
                // Expand play area with stage progression
                playAreaSize = Math.min(2.5, playAreaSize + 0.1);
                showStageTransition();
                
                // Apply random buff if modifier is active
                if (selectedModifiers.includes('random-buff')) {
                    applyRandomBuff();
                }
            }
            // Every 10 kills but not 30, advance substage
            else if (kills % 10 === 0 && !infiniteMode) {
                showSubstageSelection();
            }
            
            // Update game state in multiplayer (host only)
            if (multiplayerMode && isHost) {
                multiplayerManager.updateGameState();
            }
        }
    }

    function showStageTransition() {
        stageTransitionActive = true;
        stageText.textContent = `STAGE ${stage}`;
        stageTransition.style.display = 'flex';
        substageOptions.style.display = 'none';
        
        setTimeout(() => {
            stageTransition.style.display = 'none';
            stageTransitionActive = false;
            // Update stage display
            stageDisplay.textContent = `${stage}-${substage}`;
        }, 2000);
    }

    function showSubstageSelection() {
        // Skip substage selection in infinite mode
        if (infiniteMode) return;
        
        stageTransitionActive = true;
        stageText.textContent = `STAGE ${stage} - CHOOSE SUBSTAGE`;
        stageTransition.style.display = 'flex';
        substageOptions.style.display = 'flex';
        
        // Add event listeners to substage options
        const options = document.querySelectorAll('.substage-option');
        options.forEach(option => {
            option.onclick = () => {
                const selectedSubstage = parseInt(option.getAttribute('data-substage'));
                selectSubstage(selectedSubstage);
            };
        });
    }

    function selectSubstage(selectedSubstage) {
        substage = selectedSubstage;
        stageTransition.style.display = 'none';
        stageTransitionActive = false;
        
        // Apply substage benefits
        if (substage === 1) {
            // Assault substage benefits
            player.healthRegen = 0.01; // 1% health regen per second
            // Switch to auto shotgun
            weapons[2] = {
                name: "AUTO SHOTGUN", 
                key: "2", 
                damage: 1.8, 
                cooldown: 0.4, 
                speed: 8, 
                color: "#ff6600", 
                precision: 0.6, 
                pellets: 5
            };
            currentWeapon = 2;
            weaponDisplay.textContent = `${weapons[currentWeapon].name} [${weapons[currentWeapon].key}]`;
            
            // Spawn some obstacles
            for (let i = 0; i < 3; i++) {
                spawnObstacle();
            }
        } else if (substage === 2) {
            // Domination substage benefits
            // Enable convert ability
            convertAbility.style.display = 'flex';
            // Increase shield benefits
            shieldDamageReduction = 0.7; // 70% damage reduction
            shieldCooldownBonus = 0.3; // 30% cooldown reduction
            
            // Spawn more obstacles
            for (let i = 0; i < 5; i++) {
                spawnObstacle();
            }
        }
        
        // Update stage display
        stageDisplay.textContent = `${stage}-${substage}`;
        
        // Update game state in multiplayer (host only)
        if (multiplayerMode && isHost) {
            multiplayerManager.updateGameState();
        }
    }

    // Game over
    function gameOver() {
        gameActive = false;
        finalScoreDisplay.textContent = `SCORE: ${score}`;
        finalKills.textContent = kills;
        finalCombo.textContent = maxCombo;
        finalStage.textContent = `${stage}-${substage}`;
        const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 100;
        finalAccuracy.textContent = `${accuracy}%`;
        gameOverScreen.style.display = 'flex';
        
        // Update multiplayer status
        if (multiplayerMode && playerId) {
            multiplayerManager.updatePlayerStatus({
                alive: false
            });
        }
        
        // Clear game state update interval
        if (gameStateUpdateInterval) {
            clearInterval(gameStateUpdateInterval);
            gameStateUpdateInterval = null;
        }
    }

    // Initialize game
    function initGame() {
        player = new Player();
        enemies = []; allies = []; bloodDrops = []; bullets = []; grenades = []; particles = []; explosions = []; obstacles = [];
        score = 0; styleLevel = 0; stylePoints = 0; cameraShake = 0;
        cameraOffset = { x: 0, y: 0 };
        cameraZoom = 1.0;
        shotsFired = 0; shotsHit = 0; kills = 0; combo = 0; maxCombo = 0;
        difficulty = 1; dashCooldown = 0; parryCooldown = 0; grenadeCooldown = 0; convertCooldown = 0; parryActive = false;
        bloodIntensity = 0; playAreaSize = 1.0; stage = 1; substage = 0; enemySpawnTimer = 0;
        zoomLevel = 1.0;
        aimAssistTarget = null;
        aimAssistStrength = 0;
        healthRegenTimer = 0;
        infiniteMode = selectedModifiers.includes('infinite-mode');
        multiplayerPlayers = {};
        healthFill.style.width = '100%';
        shieldBar.style.width = '0%';
        shieldEffect.style.opacity = '0';
        styleMeter.textContent = styleRankings[styleLevel];
        styleFill.style.width = '0%';
        scoreDisplay.textContent = `SCORE: ${score}`;
        weaponDisplay.textContent = `${weapons[currentWeapon].name} [${weapons[currentWeapon].key}]`;
        killCount.textContent = '0'; comboCount.textContent = '0'; accuracyDisplay.textContent = '100%';
        stageDisplay.textContent = '1-0';
        gameContainer.style.transform = 'scale(1)';
        chromaticAberration.style.boxShadow = '';
        convertAbility.style.display = 'none';

        // Transition from menu to game
        if (!multiplayerMode) {
            mainMenu.style.opacity = '0';
            setTimeout(() => {
                mainMenu.style.display = 'none';
                gameContainer.style.display = 'block';
                setTimeout(() => {
                    gameContainer.style.opacity = '1';
                }, 50);
            }, 1000);
        } else {
            gameContainer.style.display = 'block';
            gameContainer.style.opacity = '1';
        }

        gameActive = true;

        // Reset ability cooldowns
        dashAbility.classList.remove('cooldown');
        parryAbility.classList.remove('cooldown');
        grenadeAbility.classList.remove('cooldown');
        convertAbility.classList.remove('cooldown');

        if (styleTimeout) clearTimeout(styleTimeout);
        startStyleDecay();
        
        // Start game state updates for multiplayer host
        if (multiplayerMode && isHost) {
            gameStateUpdateInterval = setInterval(() => {
                multiplayerManager.updateGameState();
            }, 1000); // Update every second
        }
    }

    // Draw function
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply camera effects
        ctx.save();
        ctx.translate(cameraOffset.x, cameraOffset.y);
        ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(-cameraOffset.x, -cameraOffset.y);
        
        // Draw play area bounds
        drawPlayAreaBounds();
        
        // Draw aim line
        drawAimLine();
        
        // Draw obstacles
        for (const obstacle of obstacles) obstacle.draw();
        
        // Draw blood drops
        for (const blood of bloodDrops) blood.draw();
        
        // Draw particles
        for (const particle of particles) particle.draw();
        
        // Draw grenades
        for (const grenade of grenades) grenade.draw();
        
        // Draw bullets
        for (const bullet of bullets) bullet.draw();
        
        // Draw enemies
        for (const enemy of enemies) enemy.draw();
        
        // Draw allies
        for (const ally of allies) ally.draw();
        
 // Draw local player
    if (player) player.draw();
    
    // Draw multiplayer players
    for (const playerId in window.multiplayerPlayerObjects) {
        if (playerId !== playerId) { // Skip local player
            window.multiplayerPlayerObjects[playerId].draw();
        }
    }
            
        // Draw explosions
        for (const explosion of explosions) {
            const alpha = explosion.life;
            const size = explosion.size * alpha;
            
            ctx.save();
            ctx.globalAlpha = alpha * 0.7;
            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, size, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
                explosion.x, explosion.y, 0,
                explosion.x, explosion.y, size
            );
            gradient.addColorStop(0, explosion.color);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
        }
        
        ctx.restore();
    }

    // Update function
    function update(deltaTime) {
        if (!gameActive || stageTransitionActive) return;
        
        // Update camera effects
        if (cameraShake > 0) {
            cameraShake *= 0.9;
            if (cameraShake < 0.1) {
                cameraShake = 0;
                cameraOffset.x = 0;
                cameraOffset.y = 0;
                cameraZoom = 1.0;
                chromaticAberration.style.boxShadow = '';
            } else {
                cameraOffset.x = (Math.random() - 0.5) * cameraShake;
                cameraOffset.y = (Math.random() - 0.5) * cameraShake;
                cameraZoom = 1.0 - cameraShake * 0.01;
            }
        }
        
        // Update buff timer
        if (currentBuff) {
            buffTimer -= deltaTime;
            if (buffTimer <= 0) {
                currentBuff.revert(player);
                currentBuff = null;
            }
        }
        
        // Find aim assist target
        aimAssistTarget = null;
        let closestDist = 100;
        for (const enemy of enemies) {
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 150 && dist < closestDist) {
                const enemyAngle = Math.atan2(dy, dx);
                let angleDiff = Math.abs(player.rotation - enemyAngle);
                angleDiff = Math.min(angleDiff, Math.PI*2 - angleDiff);
                if (angleDiff < 0.5) {
                    closestDist = dist;
                    aimAssistTarget = enemy;
                    aimAssistStrength = 0.5 * (1 - dist/150);
                }
            }
        }
        
        // Update player
        player.update(deltaTime);
        
        // Spawn enemies
        spawnEnemy(deltaTime);
        
        // Occasionally spawn obstacles in substages
        if (substage > 0 && Math.random() < 0.005) {
            spawnObstacle();
        }
        
        // Update enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            e.update(deltaTime);
            if (e.health <= 0) enemies.splice(i,1);
        }
        
        // Update allies
        for (let i = allies.length - 1; i >= 0; i--) {
            const a = allies[i];
            a.update(deltaTime);
            if (a.health <= 0) allies.splice(i,1);
        }
        
        // Update obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            if (obstacles[i].update(deltaTime)) obstacles.splice(i,1);
        }
        
        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            if (b.update()) { bullets.splice(i,1); continue; }
            // Collision with enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
                const en = enemies[j];
                const dx = b.x - en.x, dy = b.y - en.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.radius + en.radius) {
                    shotsHit++; updateAccuracy();
                    if (en.takeDamage(b.damage)) enemies.splice(j,1);
                    if (!b.pierce) {
                        bullets.splice(i,1);
                        break;
                    }
                }
            }
            // Collision with allies
            for (let j = allies.length - 1; j >= 0; j--) {
                const a = allies[j];
                const dx = b.x - a.x, dy = b.y - a.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.radius + a.radius) {
                    if (a.takeDamage(b.damage)) allies.splice(j,1);
                    if (!b.pierce) {
                        bullets.splice(i,1);
                        break;
                    }
                }
            }
        }
        
        // Update grenades
        for (let i = grenades.length - 1; i >= 0; i--) {
            if (grenades[i].update(deltaTime)) grenades.splice(i,1);
        }
        
        // Update blood drops
        for (let i = bloodDrops.length - 1; i >= 0; i--) {
            if (bloodDrops[i].update()) bloodDrops.splice(i,1);
        }
        
        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
            if (particles[i].update()) particles.splice(i,1);
        }
        
        // Update explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
            explosions[i].life -= deltaTime;
            if (explosions[i].life <= 0) explosions.splice(i,1);
        }
        
        // Update cooldowns
        if (dashCooldown > 0) { 
            dashCooldown -= deltaTime; 
            dashAbility.classList.toggle('cooldown', dashCooldown > 0);
            if (dashCooldown <= 0) dashAbility.classList.add('ready');
        } else {
            dashAbility.classList.remove('ready');
        }
        
        if (parryCooldown > 0) { 
            parryCooldown -= deltaTime; 
            parryAbility.classList.toggle('cooldown', parryCooldown > 0);
            if (parryCooldown <= 0) parryAbility.classList.add('ready');
        } else {
            parryAbility.classList.remove('ready');
        }
        
        if (grenadeCooldown > 0) { 
            grenadeCooldown -= deltaTime; 
            grenadeAbility.classList.toggle('cooldown', grenadeCooldown > 0);
            if (grenadeCooldown <= 0) grenadeAbility.classList.add('ready');
        } else {
            grenadeAbility.classList.remove('ready');
        }
        
        if (convertCooldown > 0) { 
            convertCooldown -= deltaTime; 
            convertAbility.classList.toggle('cooldown', convertCooldown > 0);
            if (convertCooldown <= 0) convertAbility.classList.add('ready');
        } else {
            convertAbility.classList.remove('ready');
        }
        
        // Decay blood intensity
        if (bloodIntensity > 0) {
            bloodIntensity = Math.max(bloodIntensity - 0.01, 0);
            bloodOverlay.style.opacity = bloodIntensity;
        }
        
        // Update crosshair position
        updateCrosshair();
    }

    // Main game loop
    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const deltaTime = Math.min(0.05, (timestamp - lastTime) / 1000);
        lastTime = timestamp;

        update(deltaTime);
        draw();
        
        requestAnimationFrame(gameLoop);
    }

    // Input handling
    window.addEventListener('keydown', (e)=>{
        keys[e.code] = true;
        if (e.code === 'Digit1') switchWeapon(0);
        if (e.code === 'Digit2') switchWeapon(1);
        if (e.code === 'Digit3') switchWeapon(3); // Skip auto shotgun (index 2)
        if (e.code === 'Digit4') switchWeapon(4);
        if (e.code === 'ShiftLeft' && gameActive && player) player.dash();
        if (e.code === 'KeyE' && gameActive && player) player.parry();
        if (e.code === 'KeyQ' && gameActive && player) player.throwGrenade();
        if (e.code === 'KeyF' && gameActive && player && substage === 2) player.convertEnemy();
    });
    
    window.addEventListener('keyup', (e)=>{ keys[e.code] = false; });

    canvas.addEventListener('mousemove', (e)=>{
        const rect = canvas.getBoundingClientRect();
        mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        // Update custom cursor position
        customCursor.style.left = `${e.clientX}px`;
        customCursor.style.top = `${e.clientY}px`;
        cursorDot.style.left = `${e.clientX}px`;
        cursorDot.style.top = `${e.clientY}px`;
    });

    canvas.addEventListener('click', (e)=>{
        if (gameActive && player) {
            player.shoot();
        }
    });

    // Custom cursor movement
    document.addEventListener('mousemove', (e) => {
        customCursor.style.left = `${e.clientX}px`;
        customCursor.style.top = `${e.clientY}px`;
        cursorDot.style.left = `${e.clientX}px`;
        cursorDot.style.top = `${e.clientY}px`;
    });

    function switchWeapon(index) {
        if (index >= 0 && index < weapons.length) {
            // Skip auto shotgun if not in substage 1
            if (index === 2 && substage !== 1) return;
            
            currentWeapon = index;
            weaponDisplay.textContent = `${weapons[currentWeapon].name} [${weapons[currentWeapon].key}]`;
            weaponDisplay.style.animation = 'none';
            setTimeout(() => {
                weaponDisplay.style.animation = 'weaponPulse 2s infinite alternate';
            }, 10);
        }
    }

    // UI event handlers
    singleplayerButton.addEventListener('click', ()=>{
        playerName = playerNameInput.value || "Player";
        initSettings();
        multiplayerMode = false;
        initGame();
        // Hide cursor during gameplay
        document.body.classList.remove('menu-mode');
        customCursor.style.display = 'none';
        cursorDot.style.display = 'none';
    });
    
    hostButton.addEventListener('click', async ()=>{
        playerName = playerNameInput.value || "Player";
        initSettings();
        const gameId = await multiplayerManager.createGame(playerName);
        if (gameId) {
            gameCodeDisplay.textContent = `CODE: ${gameId}`;
            multiplayerMode = true;
            
            // Show lobby
            mainMenu.style.opacity = '0';
            setTimeout(() => {
                mainMenu.style.display = 'none';
                multiplayerLobby.style.display = 'flex';
            }, 1000);
        }
    });
    
    joinButton.addEventListener('click', async ()=>{
        playerName = playerNameInput.value || "Player";
        initSettings();
        const gameCode = prompt("Enter game code:");
        if (gameCode) {
            const success = await multiplayerManager.joinGame(gameCode.toUpperCase(), playerName);
            if (success) {
                gameCodeDisplay.textContent = `CODE: ${gameCode.toUpperCase()}`;
                multiplayerMode = true;
                
                // Show lobby
                mainMenu.style.opacity = '0';
                setTimeout(() => {
                    mainMenu.style.display = 'none';
                    multiplayerLobby.style.display = 'flex';
                }, 1000);
            }
        }
    });
    
    modifiersButton.addEventListener('click', ()=>{
        modifiersPanel.style.display = 'flex';
    });
    
    modifiersBackButton.addEventListener('click', ()=>{
        modifiersPanel.style.display = 'none';
    });
    
    modifiersConfirmButton.addEventListener('click', ()=>{
        modifiersPanel.style.display = 'none';
        // Save selected modifiers
        selectedModifiers = [];
        document.querySelectorAll('.modifier-option.selected').forEach(option => {
            selectedModifiers.push(option.getAttribute('data-modifier'));
        });
    });
    
    tutorialButton.addEventListener('click', ()=>{
        guidebook.style.display = 'flex';
    });
    
    settingsButton.addEventListener('click', ()=>{
        settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    });
    
    quitButton.addEventListener('click', ()=>{
        if (confirm("Are you sure you want to quit?")) {
            window.close();
        }
    });
    
    restartButton.addEventListener('click', ()=>{
        gameOverScreen.style.display = 'none';
        initGame();
    });
    
    menuButton.addEventListener('click', async ()=>{
        gameOverScreen.style.display = 'none';
        gameContainer.style.opacity = '0';
        
        // Leave multiplayer game if in multiplayer mode
        if (multiplayerMode) {
            await multiplayerManager.leaveGame();
        }
        
        setTimeout(() => {
            gameContainer.style.display = 'none';
            mainMenu.style.display = 'flex';
            setTimeout(() => {
                mainMenu.style.opacity = '1';
                startMenuAnimation();
                // Show cursor in menu
                document.body.classList.add('menu-mode');
                customCursor.style.display = 'block';
                cursorDot.style.display = 'block';
            }, 50);
        }, 1000);
    });
    
    backButton.addEventListener('click', ()=>{
        guidebook.style.display = 'none';
    });
    
    lobbyBackButton.addEventListener('click', async ()=>{
        // Leave multiplayer game
        await multiplayerManager.leaveGame();
        
        multiplayerLobby.style.display = 'none';
        mainMenu.style.display = 'flex';
        setTimeout(() => {
            mainMenu.style.opacity = '1';
        }, 50);
    });
    
    readyButton.addEventListener('click', ()=>{
        playerReady = !playerReady;
        multiplayerManager.setReadyStatus(playerReady);
        readyButton.textContent = playerReady ? 'NOT READY' : 'READY';
    });
    
    startGameButton.addEventListener('click', ()=>{
        multiplayerManager.startGame();
    });

    // Modifier selection
    document.querySelectorAll('.modifier-option').forEach(option => {
        option.addEventListener('click', () => {
            option.classList.toggle('selected');
        });
    });

    // Initialize settings from sliders
    function initSettings() {
        graphicsQuality = parseInt(document.getElementById('graphics-quality').value);
        masterVolume = parseInt(document.getElementById('master-volume').value) / 100;
        effectsVolume = parseInt(document.getElementById('effects-volume').value) / 100;
        musicVolume = parseInt(document.getElementById('music-volume').value) / 100;
    }

    // Simulate loading progress
    function simulateLoading() {
        let progress = 0;
        const interval = setInterval(() => {
            progress += Math.random() * 5;
            progressFill.style.width = `${Math.min(progress, 100)}%`;
            
            if (progress >= 100) {
                clearInterval(interval);
                setTimeout(() => {
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        mainMenu.style.display = 'flex';
                        setTimeout(() => {
                            mainMenu.style.opacity = '1';
                            startMenuAnimation();
                            // Show cursor in menu
                            document.body.classList.add('menu-mode');
                            customCursor.style.display = 'block';
                            cursorDot.style.display = 'block';
                        }, 50);
                    }, 1000);
                }, 500);
            }
        }, 100);
    }

    // Start menu animation
    function startMenuAnimation() {
        // Setup menu canvas
        menuCanvas.width = menuCanvas.offsetWidth;
        menuCanvas.height = menuCanvas.offsetHeight;
        
        // Start menu animation loop
        menuAnimationLoop();
    }

    // Menu animation loop
    function menuAnimationLoop() {
        if (mainMenu.style.display !== 'flex') return;
        
        // Clear menu canvas
        menuCtx.fillStyle = '#0a0a0a';
        menuCtx.fillRect(0, 0, menuCanvas.width, menuCanvas.height);
        
        // Draw some demo enemies and effects
        const time = Date.now() * 0.001;
        
        // Draw grid
        menuCtx.strokeStyle = '#ff003c';
        menuCtx.lineWidth = 1;
        menuCtx.setLineDash([5, 5]);
        menuCtx.beginPath();
        for (let x = 0; x < menuCanvas.width; x += 20) {
            menuCtx.moveTo(x, 0);
            menuCtx.lineTo(x, menuCanvas.height);
        }
        for (let y = 0; y < menuCanvas.height; y += 20) {
            menuCtx.moveTo(0, y);
            menuCtx.lineTo(menuCanvas.width, y);
        }
        menuCtx.stroke();
        menuCtx.setLineDash([]);
        
        // Draw demo player
        const playerX = menuCanvas.width / 2;
        const playerY = menuCanvas.height / 2;
        const playerSize = 15;
        
        menuCtx.fillStyle = '#ff003c';
        menuCtx.beginPath();
        menuCtx.arc(playerX, playerY, playerSize, 0, Math.PI * 2);
        menuCtx.fill();
        
        menuCtx.strokeStyle = '#fff';
        menuCtx.lineWidth = 2;
        menuCtx.beginPath();
        menuCtx.arc(playerX, playerY, playerSize, 0, Math.PI * 2);
        menuCtx.stroke();
        
        // Draw demo enemies
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2 + time;
            const radius = 100;
            const x = playerX + Math.cos(angle) * radius;
                       const y = playerY + Math.sin(angle) * radius;
            const size = 10 + Math.sin(time + i) * 3;
            
            menuCtx.fillStyle = i % 2 === 0 ? '#6666ff' : '#ff3333';
            menuCtx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            menuCtx.fill();
            
            menuCtx.strokeStyle = '#fff';
            menuCtx.lineWidth = 1;
            menuCtx.beginPath();
            menuCtx.arc(x, y, size, 0, Math.PI * 2);
            menuCtx.stroke();
        }
        
        // Draw demo bullets
        for (let i = 0; i < 8; i++) {
            const angle = time + i * 0.5;
            const dist = 50 + Math.sin(time * 2 + i) * 20;
            const x = playerX + Math.cos(angle) * dist;
            const y = playerY + Math.sin(angle) * dist;
            const size = 3;
            
            menuCtx.fillStyle = '#ffcc00';
            menuCtx.beginPath();
            menuCtx.arc(x, y, size, 0, Math.PI * 2);
            menuCtx.fill();
        }
        
        // Draw demo blood splatters
        for (let i = 0; i < 3; i++) {
            const angle = time + i * 2;
            const dist = 70 + Math.sin(time + i) * 10;
            const x = playerX + Math.cos(angle) * dist;
            const y = playerY + Math.sin(angle) * dist;
            const size = 5 + Math.sin(time * 3 + i) * 2;
            
            menuCtx.fillStyle = 'rgba(255, 0, 60, 0.7)';
            menuCtx.beginPath();
            menuCtx.arc(x, y, size, 0, Math.PI * 2);
            menuCtx.fill();
        }
        
        requestAnimationFrame(menuAnimationLoop);
    }

    // Start the game
    simulateLoading();
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
